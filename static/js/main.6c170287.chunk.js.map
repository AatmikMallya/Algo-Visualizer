{"version":3,"sources":["resources/fonts/FiraCode-Regular.ttf","components/LengthSlider.js","components/SpeedSlider.js","components/Menu.js","components/Info.js","algorithms/Selection.js","animations/SelectionAnimation.js","algorithms/Insertion.js","animations/InsertionAnimation.js","algorithms/Merge.js","animations/MergeAnimation.js","algorithms/Quick.js","animations/QuickAnimation.js","algorithms/Heap.js","animations/HeapAnimation.js","algorithms/Shell.js","animations/ShellAnimation.js","algorithms/Counting.js","animations/CountingAnimation.js","algorithms/Radix.js","animations/RadixAnimation.js","algorithms/Bucket.js","animations/BucketAnimation.js","algorithms/Bubble.js","animations/BubbleAnimation.js","algorithms/Comb.js","animations/CombAnimation.js","components/SortingHelpers.js","components/InfoBox.js","components/Timer.js","components/SortingTimeVisualizer.js","App.js","serviceWorker.js","index.js","resources/card-flip.mp3","resources/card-flip-2.mp3"],"names":["module","exports","useStyles","makeStyles","root","width","color","input","backgroundColor","borderRadius","slider","LengthSlider","props","classes","React","useState","value","setValue","useEffect","onSlide","className","Typography","id","gutterBottom","Grid","container","spacing","alignItems","item","xs","Slider","min","max","onChange","event","newValue","aria-labelledby","Input","margin","target","Number","onBlur","inputProps","step","type","style","textAlign","disableUnderline","SpeedSlider","Menu","handleSpeedChange","interval","onSpeedChange","handleGenerate","length","onGenerate","handleExecute","onExecute","handleReset","onReset","handleSelect","onSelect","document","getElementById","render","onClick","label","Component","sq","t","info","selection","header","best","avg","worst","space","algo","insertion","merge","quick","heap","shell","counting","radix","bucket","bubble","comb","getSelectionAnimations","arr","animations","i","minIdx","push","j","animateSelectionSort","stateArray","a","getElementsByClassName","colors","purple","wait","animationInterval","isRunning","cardFlip","play","green","idx1","idx2","yellow","height","innerHTML","slice","idx","red","getInsertionAnimations","temp","console","log","insertionAlgo","animateInsertionSort","gradients","3","1","2","4","8","5","16","6","32","7","64","getMergeAnimations","b","level","Math","ceil","log2","mergeAnimate","left","right","end","k","animateMergeSort","getQuickAnimations","index","pivotIdx","floor","pivot","partitionAnimate","animateQuickSort","sort","value1","parseInt","value2","getHeapAnimations","len","heapifyAnimate","largest","animateHeapSort","playCount","isGreen","cardFlip2","getShellAnimations","gap","animateShellSort","oldColor","getCountingAnimations","count","hue","mapToHue","animateCountingSort","getRadixAnimations","digits","toString","buckets","Array","from","getDigit","flat","valueToHue","0","9","num","place","pow","animateRadixSort","getBucketAnimations","size","map","tempArr","forEach","element","animateBucketSort","newArr","getBubbleAnimations","animateBubbleSort","getCombAnimations","iteration","isSorted","front","back","animateCombSort","menuColors","algoColors","lerp","u","themeFade","start","step_u","menu","icon","querySelector","infoButton","setProperty","getMenuHue","match","r","g","d","barFade","isReset","hexToRgb","hex","result","exec","Transition","forwardRef","ref","Slide","direction","InfoBox","text","algorithm","styles","button","fontSize","position","bottom","display","fontWeight","bold","normal","fontFamily","paper","maxHeight","minWidth","subHeader","marginTop","marginBottom","textDecoration","exit","open","setOpen","handleClose","Button","variant","Dialog","PaperProps","dialog","scroll","TransitionComponent","keepMounted","onClose","aria-describedby","DialogTitle","DialogContent","DialogContentText","ReactHtmlParser","DialogActions","Timer","startTimer","setState","status","timeStart","Date","now","state","time","timer","setInterval","stopTimer","clearInterval","resetTimer","setStatus","bool","setTimeout","centiseconds","seconds","minutes","version","xmlns","viewBox","enableBackground","UIfx","cardFlipMp3","throttleMs","volume","cardFlip2Mp3","ms","Promise","res","SortingTimeVisualizer","componentDidMount","clientHeight","body","getBoundingClientRect","selectAlgorithm","setRunning","timerElement","current","classList","add","remove","speedChange","generateArray","arraySize","array","defaultLength","windowWidth","window","innerWidth","radius","newArray","random","newBars","key","undefined","marginLeft","marginRight","bars","storedArray","resetArray","oldArray","oldHue","help","newHue","createRef","App","ReactGA","initialize","pageview","location","pathname","isLocalhost","Boolean","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","error","ReactDOM","StrictMode","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.6c170287.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/FiraCode-Regular.dc34dd99.ttf\";","import React, { useEffect } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport Slider from '@material-ui/core/Slider';\nimport Input from '@material-ui/core/Input';\nimport '../css/Menu.css';\n\nconst useStyles = makeStyles({\n  root: {\n    width: 250,\n    color: 'rgba(100%, 100%, 100%, 82.5%)',\n  },\n  input: {\n    width: 50,\n    color: 'rgba(100%, 100%, 100%, 82.5%)',\n    backgroundColor: 'rgba(100%, 100%, 100%, 20%)',\n    borderRadius: '10px',\n  },\n  slider: {\n    color: 'rgba(100%, 100%, 100%, 82.5%)'\n  }\n});\n\nexport default function LengthSlider(props) {\n  const classes = useStyles();\n  const [value, setValue] = React.useState(25);\n\n  useEffect(() => {\n    if (value < 5) {\n      props.onSlide(5);\n    } else if (value > 125) {\n      props.onSlide(125);\n    } else {\n      props.onSlide(value);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value]);\n\n  const handleSliderChange = (event, newValue) => {\n    setValue(newValue);\n  };\n\n  const handleInputChange = (event) => {\n    setValue(event.target.value === '' ? '' : Number(event.target.value));\n  };\n\n  const handleBlur = () => {\n    if (value < 5) {\n      setValue(5);\n    } else if (value > 125) {\n      setValue(125);\n    }\n  };\n\n  return (\n    <div className={classes.root}>\n      <Typography className='slider-label' id='input-slider' gutterBottom >\n        Array Length\n      </Typography >\n      <Grid container spacing={2} alignItems='center'>\n        <Grid item xs>\n          <Slider\n            className={classes.slider}\n            min={5}\n            max={125}\n            value={typeof value === 'number' ? value : 0}\n            onChange={handleSliderChange}\n            aria-labelledby='input-slider'\n          />\n        </Grid>\n        <Grid item>\n          <Input\n            className={classes.input}\n            value={value}\n            margin='dense'\n            onChange={handleInputChange}\n            onBlur={handleBlur}\n            inputProps={{\n              step: 10,\n              min: 5,\n              max: 125,\n              type: 'number',\n              'aria-labelledby': 'input-slider',\n              style: {textAlign: 'center', color: 'white'},\n            }}\n            disableUnderline\n          />\n        </Grid>\n      </Grid>\n    </div>\n  );\n}\n","import React, { useEffect } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport Slider from '@material-ui/core/Slider';\n\nconst useStyles = makeStyles({\n  root: {\n    width: 220,\n    color: 'rgba(100%, 100%, 100%, 82.5%)'\n  },\n  slider: {\n    color: 'rgba(100%, 100%, 100%, 82.5%)'\n  }\n});\n\n// Sets the time interval between animation frames\nexport default function SpeedSlider(props) {\n  const classes = useStyles();\n  const [value, setValue] = React.useState(10);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => props.onSlide(value), [value]);\n\n  const handleChange = (event, newValue) => setValue(newValue);\n\n  return (\n    <div className={classes.root}>\n      <Typography className='slider-label' id='continuous-slider' gutterBottom>\n        Sorting Speed\n      </Typography>\n      <Grid container spacing={2}>\n        <Grid item>\n        </Grid>\n        <Grid item xs>\n          <Slider value={value} onChange={handleChange} className={classes.slider} aria-labelledby='continuous-slider' />\n        </Grid>\n        <Grid item>\n        </Grid>\n      </Grid>\n    </div>\n  );\n}","import React from 'react';\nimport LengthSlider from './LengthSlider';\nimport SpeedSlider from './SpeedSlider';\nimport '../css/Menu.css';\n\nexport default class Menu extends React.Component {\n    // Event handlers for menu items\n    handleSpeedChange = interval => this.props.onSpeedChange(interval);\n    handleGenerate = length => this.props.onGenerate(length);\n    handleExecute = () => this.props.onExecute();\n    handleReset = () => this.props.onReset();\n\n    handleSelect = () => this.props.onSelect(document.getElementById('menu-select').value);\n\n    render = () => {\n        return (\n            <div id='menu-container'>\n                <div className='menu-item' id='generate' onClick={() => this.handleGenerate()}>New Array</div>\n                <div className='menu-item' id='reset' onClick={() => this.handleReset()}>Reset Array</div>\n                <SpeedSlider onSlide={interval => this.handleSpeedChange(interval)} />\n                <LengthSlider onSlide={length => this.handleGenerate(length)} />\n                <select className='menu-item' id='menu-select' onChange={() => this.handleSelect()}>\n                    <optgroup className='group' label='Simple Sorts'>\n                        <option value='selection'>Selection sort</option>\n                        <option value='insertion'>Insertion sort</option>\n                    </optgroup>\n                    <optgroup className='group' label='Efficient Sorts'>\n                        <option value='merge'>Merge sort</option>\n                        <option value='quick'>Quicksort</option>\n                        <option value='heap'>Heapsort</option>\n                        <option value='shell'>Shell sort</option>\n                    </optgroup>\n                    <optgroup className='group' label='Distribution Sorts'>\n                        <option value='counting'>Counting sort</option>\n                        <option value='radix'>Radix sort</option>\n                        <option value='bucket'>Bucket sort</option>\n                    </optgroup>\n                    <optgroup className='group' label='Other Sorts'>\n                        <option value='bubble'>Bubble sort</option>\n                        <option value='comb'>Comb sort</option>\n                    </optgroup>\n                </select>\n                <div className='menu-item' id='execute' onClick={() => this.handleExecute()}>Execute</div>\n            </div>\n        );\n    }\n}\n","// Contains all text displayed in the info box\n// Rendered in InfoBox.js\nconst sq = `<sup style='vertical-align: top; font-size: 0.6em;'>2</sup>`;\nconst t = `&nbsp;&nbsp;&nbsp;&nbsp;`;\nconst info = {\n    selection: {\n        header: `Selection Sort`,\n        best: `n${sq}`,\n        avg: `n${sq}`,\n        worst: `n${sq}`,\n        space: `1`,\n        algo: `\n        function selectionSort(arr) {<br/>\n        ${t}for (let i = 0; i < arr.length; i++) {<br/>\n        ${t}${t}let minIdx = i;<br/>\n        ${t}${t}for (let j = i+1; j < arr.length; j++) {<br/>\n        ${t}${t}${t}if (arr[j] < arr[minIdx]) {<br/>\n        ${t}${t}${t}${t}minIdx = j;<br/>\n        ${t}${t}${t}}<br/>\n        ${t}${t}}<br/>\n        ${t}${t}if (minIdx > i) {<br/>\n        ${t}${t}${t}[arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];<br/>\n        ${t}${t}}<br/>\n        ${t}}<br/>\n        ${t}return arr;<br/>\n        }`\n    },\n    insertion: {\n        header: `Insertion Sort`,\n        best: `n`,\n        avg: `n${sq}`,\n        worst: `n${sq}`,\n        space: `1`,\n        algo: `\n        function insertionSort(arr) {<br/>\n        ${t}for (let i = 1; i < arr.length; i++) {<br/>\n        ${t}${t}let j = i-1;<br/>\n        ${t}${t}const temp = arr[i];<br/>\n        ${t}${t}while (j >= 0 && arr[j] > temp) {<br/>\n        ${t}${t}${t}arr[j+1] = arr[j];<br/>\n        ${t}${t}${t}j--;<br/>\n        ${t}${t}}<br/>\n        ${t}${t}arr[j+1] = temp;<br/>\n        ${t}}<br/>\n        ${t}return arr;<br/>\n        }`\n    },\n    merge: {\n        header: `Merge Sort`,\n        best: `n log(n)`,\n        avg: `n log(n)`,\n        worst: `n log(n)`,\n        space: `n`,\n        algo: `\n        function mergeSort(arr) {<br/>\n        ${t}if (arr.length < 2) return arr;<br/><br/>\n        ${t}var mid = Math.floor(arr.length / 2);<br/>\n        ${t}var left = mergeSort(arr.slice(0, mid));<br/>\n        ${t}var right = mergeSort(arr.slice(mid));<br/><br/>\n        ${t}return merge(left, right);<br/>\n        }<br/>\n        <br/>\n        function merge(a, b) {<br/>\n        ${t}var result = [];<br/><br/>\n        ${t}while (a.length > 0 && b.length > 0) {<br/>\n        ${t}${t}result.push(a[0] < b[0] ? a.shift() : b.shift());<br/>\n        ${t}}<br/><br/>\n        ${t}return result.concat(a.length? a : b);<br/>\n        }`\n    },\n    quick: {\n        header: `Quicksort`,\n        best: `n log(n)`,\n        avg: `n log(n)`,\n        worst: `n${sq}`,\n        space: `log(n)`,\n        algo: `\n        function quicksort(arr, left, right) {<br/>\n        ${t}let index;<br/>\n        ${t}if (arr.length > 1) {<br/>\n        ${t}${t}index = partition(arr, left, right);<br/>\n        ${t}${t}if (left < index-1) {<br/>\n        ${t}${t}${t}quicksort(arr, left, index-1);<br/>\n        ${t}${t}}<br/>\n        ${t}${t}if (index < right) {<br/>\n        ${t}${t}${t}quicksort(arr, index, right);<br/>\n        ${t}${t}}<br/>\n        ${t}}<br/>\n        ${t}return arr;<br/>\n        }<br/>\n        <br/>\n        function partition(arr, left, right) {<br/>\n        ${t}const pivot = arr[Math.floor((right+left) / 2)];<br/>\n        <br/>\n        ${t}let i = left;<br/>\n        ${t}let j = right;<br/>\n        <br/>\n        ${t}while (i < j+1) {<br/>\n        ${t}${t}while (arr[i] < pivot) {<br/>\n        ${t}${t}${t}i++;<br/>\n        ${t}${t}}<br/>\n        ${t}${t}while (arr[j] > pivot) {<br/>\n        ${t}${t}${t}j--;<br/>\n        ${t}${t}}<br/>\n        ${t}${t}if (i < j+1) {<br/>\n        ${t}${t}${t}[arr[i], arr[j]] = [arr[j], arr[i]];<br/>\n        ${t}${t}${t}i++;<br/>\n        ${t}${t}${t}j--;<br/>\n        ${t}${t}}<br/>\n        ${t}}<br/>\n        ${t}return i;<br/>\n        }`\n    },\n    heap: {\n        header: `Heapsort`,\n        best: `n log(n)`,\n        avg: `n log(n)`,\n        worst: `n log(n)`,\n        space: `1`,\n        algo: `\n        function heapsort(arr) {<br/>\n        ${t}const len = arr.length;<br/>\n        ${t}let i  = Math.floor(len/2 - 1);<br/>\n        ${t}let j = len - 1;<br/>\n        <br/>\n        ${t}while (i >= 0) {<br/>\n        ${t}${t}heapify(arr, len, i);<br/>\n        ${t}${t}i--;<br/>\n        ${t}}<br/>\n        <br/>\n        ${t}while (j >= 0) {<br/>\n        ${t}${t}[arr[0], arr[j]] = [arr[j], arr[0]];<br/>\n        ${t}${t}heapify(arr, j, 0);<br/>\n        ${t}${t}j--;<br/>\n        ${t}}<br/>\n        <br/>\n        ${t}return arr;<br/>\n        }<br/>\n        <br/>\n        function heapify(arr, len, i) {<br/>\n        ${t}let largest = i;<br/>\n        ${t}const left = i*2 + 1;<br/>\n        ${t}const right = left + 1;<br/>\n        <br/>\n        ${t}if (left < len && arr[left] > arr[largest]) {<br/>\n        ${t}${t}largest = left;<br/>\n        ${t}}<br/>\n        ${t}if (right < len && arr[right] > arr[largest]) {<br/>\n        ${t}${t}largest = right;<br/>\n        ${t}}<br/>\n        <br/>\n        ${t}if (largest !== i) {<br/>\n        ${t}${t}[arr[i], arr[largest]] = [arr[largest], arr[i]];<br/>\n        ${t}${t}heapify(arr, len, largest);<br/>\n        ${t}}<br/>\n        }`\n    },\n    shell: {\n        header: `Shell Sort`,\n        best: `n log(n)`,\n        avg: `n log(n)${sq}`,\n        worst: `n log(n)${sq}`,\n        space: `1`,\n        algo: `\n        function shellSort(arr) {<br/>\n        ${t}const len = arr.length;<br/>\n        ${t}let gap = Math.floor(len / 2);<br/>\n        ${t}while (gap > 0) {<br/>\n        ${t}${t}for (let i = gap; i < len; i++) {<br/>\n        ${t}${t}${t}const temp = arr[i];<br/>\n        ${t}${t}${t}let j = i;<br/>\n        ${t}${t}${t}while (j >= gap && arr[j-gap] > temp) {<br/>\n        ${t}${t}${t}${t}arr[j] = arr[j-gap];<br/>\n        ${t}${t}${t}${t}j -= gap;<br/>\n        ${t}${t}${t}}<br/>\n        ${t}${t}${t}arr[j] = temp;<br/>\n        ${t}${t}}<br/>\n        ${t}${t}gap = Math.floor(gap / 2);<br/>\n        ${t}}<br/>\n        ${t}return arr;<br/>\n        }`\n    },\n    counting: {\n        header: `Counting Sort`,\n        best: `n+k`,\n        avg: `n+k`,\n        worst: `n+k`,\n        space: `k`,\n        algo: `\n        function countingSort(arr) {<br/>\n        ${t}max = Math.max(...arr);<br/>\n        ${t}min = Math.min(...arr);<br/>\n        ${t}let i = min;<br/>\n        ${t}let j = 0;<br/>\n        ${t}let count = [];<br/>\n        <br/>\n        ${t}for (i; i < max + 1; i++) {<br/>\n        ${t}${t}count[i] = 0;<br/>\n        ${t}}<br/>\n        ${t}for (i = 0; i < arr.length; i++) {<br/>\n        ${t}${t}count[arr[i]]++;<br/>\n        ${t}}<br/>\n        <br/>\n        ${t}for (i = min; i < max + 1; i++) {<br/>\n        ${t}${t}while (count[i] > 0) {<br/>\n        ${t}${t}${t}arr[j] = i;<br/>\n        ${t}${t}${t}j++;<br/>\n        ${t}${t}${t}count[i]--;<br/>\n        ${t}${t}}<br/>\n        ${t}}<br/>\n        <br/>\n        ${t}return arr;<br/>\n        }`\n    },\n    radix: {\n        header: `Radix Sort`,\n        best: `nk`,\n        avg: `nk`,\n        worst: `nk`,\n        space: `n+k`,\n        algo: `\n        function radixSort(arr) {<br/>\n        ${t}const digits = Math.max(...arr).toString().length;<br/>\n        ${t}for (let i = 0; i < digits; i++) {<br/>\n        ${t}${t}const buckets = Array.from({length: 10}, () => []);<br/>\n        ${t}${t}for (let j = 0; j < arr.length; j++) {<br/>\n        ${t}${t}${t}buckets[getDigit(arr[j], i)].push(arr[j]);<br/>\n        ${t}${t}}<br/>\n        ${t}${t}arr = buckets.flat()<br/>\n        ${t}}<br/>\n        ${t}return arr;<br/>\n        }<br/>\n        <br/>\n        function getDigit(num, place) {<br/>\n        ${t}return Math.floor(num / Math.pow(10, place)) % 10;<br/>\n        }`\n    },\n    bucket: {\n        header: `Bucket Sort`,\n        best: `n+k`,\n        avg: `n+k`,\n        worst: `n${sq}`,\n        space: `n`,\n        algo: `\n        function bucketSort(arr) {<br/>\n        ${t}const size = 10;<br/>\n        ${t}let min = Math.min(...arr);<br/>\n        ${t}let max = Math.max(...arr);<br/>\n        <br/>\n        ${t}const len = Math.floor((max - min) / size) + 1;<br/>\n        ${t}const buckets = [...new Array(len)].map(() => []);<br/>\n        <br/>\n        ${t}for (let i = 0; i < arr.length; i++) {<br/>\n        ${t}${t}const bucket = Math.floor((arr[i]-min) / size);<br/>\n        ${t}${t}buckets[bucket].push(arr[i]);<br/>\n        ${t}}<br/>\n        <br/>\n        ${t}arr.length = [];<br/>\n        ${t}buckets.forEach(bucket => {<br/>\n        ${t}${t}insertionSort(bucket);<br/>\n        ${t}${t}bucket.forEach(element => arr.push(element));<br/>\n        ${t}});<br/>\n        <br/>\n        ${t}return arr;<br/>\n        }`\n    },\n    bubble: {\n        header: `Bubble Sort`,\n        best: `n`,\n        avg: `n${sq}`,\n        worst: `n${sq}`,\n        space: `1`,\n        algo: `\n        function bubbleSort(arr) {<br/>\n        ${t}for (let i = 0; i < arr.length; i++) {<br/>\n        ${t}${t}for (let j = 0; j < arr.length; j++) {<br/>\n        ${t}${t}${t}if (arr[j] > arr[j+1]) {<br/>\n        ${t}${t}${t}${t}[arr[j], arr[j+1]] = [arr[j+1], arr[j]];<br/>\n        ${t}${t}${t}}<br/>\n        ${t}${t}}<br/>\n        ${t}}<br/>\n        ${t}return arr;<br/>\n        }`\n    },\n    comb: {\n        header: `Comb Sort`,\n        best: `n`,\n        avg: `n log(n)`,\n        worst: `n${sq}`,\n        space: `1`,\n        algo: `\n        function combSort(arr) {<br/>\n        ${t}const interval = 1.3;<br/>\n        ${t}let iteration = 0;<br/>\n        ${t}let gap = arr.length - 2;<br/>\n        <br/>\n        ${t}while (!isSorted(arr)) {<br/>\n        ${t}${t}if (iteration) {<br/>\n        ${t}${t}${t}if (gap !== 1) {<br/>\n        ${t}${t}${t}${t}gap = Math.floor(gap / interval);<br/>\n        ${t}${t}${t}}<br/>\n        ${t}${t}}<br/>\n        <br/>\n        ${t}${t}let front = 0;<br/>\n        ${t}${t}for (let back = gap; back < arr.length-2; back++) {<br/>\n        ${t}${t}${t}if (arr[front] > arr[back]) {<br/>\n        ${t}${t}${t}${t}const temp = arr[front];<br/>\n        ${t}${t}${t}${t}arr[front] = arr[back];<br/>\n        ${t}${t}${t}${t}arr[back] = temp;<br/>\n        ${t}${t}${t}}<br/>\n        ${t}${t}${t}front++;<br/>\n        ${t}${t}}<br/>\n        ${t}${t}iteration++;<br/>\n        ${t}}<br/>\n        ${t}return arr;<br/>\n        }`\n    }\n};\nexport default info;\n","const purple = '#8a2be2';\nconst red = '#dc143c';\n\n// Executes sorting algorithm and determines the sequence of animations\nexport default function getSelectionAnimations(arr) {\n    const animations = [];\n    \n    for (let i = 0; i < arr.length; i++) {\n        let minIdx = i;\n        // arr[i] = purple\n        animations.push([i, purple, 'sorted'])\n        for (let j = i + 1; j < arr.length; j++) {\n            if (arr[j] < arr[minIdx]) {\n                minIdx = j;\n                // arr[j] = purple\n                animations.push([j, purple])\n            }\n            else {\n                // arr[j] = red\n                animations.push([j, red])\n            }\n        }\n\n        if (minIdx > i) {\n            [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n            // Swap a[i], a[minIdx]\n            animations.push([i, minIdx]);\n        }\n    }\n\n    return animations;\n}\n\n\n// Original selection sort algorithm\n// export function selectionAlgo(arr) {\n//     let minIdx;\n    \n//     for (let i = 0; i < arr.length; i++) {\n//         minIdx = i;\n//         for (let j = i + 1; j < arr.length; j++) {\n//             if (arr[j] < arr[minIdx]) {\n//                 minIdx = j;\n//             }\n//         }\n\n//         if (minIdx > i) {\n//             [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n//         }\n//     }\n\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getSelectionAnimations from '../algorithms/Selection';\n\n// Render selection sort animations\nexport default async function animateSelectionSort(stateArray) {\n    const animations = getSelectionAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n    \n    // First bar will be purple (current min)\n    arr[0].style.backgroundColor = colors.purple;\n    await wait(animationInterval);\n    \n    for (let i = 1; i < animations.length - 50; i++) {\n        if (!isRunning) return;\n        // Swap two elements\n        if (typeof animations[i][1] === 'number') {\n            cardFlip.play();\n            // Last element is still red\n            arr[animations[i - 1][0]].style.backgroundColor = colors.green;\n            const [idx1, idx2] = animations[i];\n\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            arr[idx1].innerHTML = arr[idx1].style.height.slice(0, -2);\n            arr[idx2].innerHTML = arr[idx2].style.height.slice(0, -2);\n            await wait(animationInterval);\n\n            arr[idx1].style.backgroundColor = colors.purple;\n            arr[idx2].style.backgroundColor = colors.green;\n            await wait(animationInterval);\n        }\n        // Color a bar red/purple to indicate result of comparison\n        else {\n            const [idx, color, type] = animations[i];\n            arr[idx].style.backgroundColor = color;\n            arr[idx].type = type;\n\n            if (animations[i - 1][1] === colors.red) {\n                arr[animations[i - 1][0]].style.backgroundColor = colors.green;\n            }\n            // Reset the previous min to green\n            if (color === colors.purple) {\n                for (let j = idx - 1; j > 0; j--) {\n                    if (arr[j].type !== 'sorted' && arr[j].style.backgroundColor === 'rgb(138, 43, 226)') { //purple\n                        arr[j].style.backgroundColor = colors.green;\n                    }\n                }\n            }\n            await wait(animationInterval);\n        }\n    }\n    \n    arr[arr.length - 1].style.backgroundColor = colors.purple;\n}\n","const purple = '#8a2be2';\n\n// Executes sorting algorithm and determines the sequence of animations\nexport default function getInsertionAnimations(arr) {\n    const animations = [];\n\n    for (let i = 1; i < arr.length; i++) {\n        let j = i - 1;\n        const temp = arr[i];\n        // arr[i] = purple\n        animations.push([i, purple])\n        while (j >= 0 && arr[j] > temp) {\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            // Swap arr[j], arr[j + 1]\n            animations.push([j, j + 1])\n            j--;\n        }\n    }\n\n    console.log('get',animations)\n    return animations;\n}\n\n\n\n// Original insertion algo\nexport function insertionAlgo(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        let j = i - 1;\n        const temp = arr[i];\n        while (j >= 0 && arr[j] > temp) {\n            arr[j+1] = arr[j];\n            j--;\n        }\n        arr[j+1] = temp;\n    }\n    return arr;\n}\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getInsertionAnimations from '../algorithms/Insertion';\n\n// Render insertion sort animations\nexport default async function animateInsertionSort(stateArray) {\n    console.log('hi')\n    const animations = getInsertionAnimations(stateArray);\n    console.log('bye')\n    const arr = document.getElementsByClassName('array');\n\n    console.log(animations)\n\n    // First bar will be purple (current min)\n    arr[0].style.backgroundColor = colors.purple;\n    await wait(animationInterval);\n    \n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // Swap two elements\n        if (typeof animations[i][1] === 'number') {\n            const [idx1, idx2] = animations[i];\n            \n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.red;\n            await wait(animationInterval);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            arr[idx1].innerHTML = arr[idx1].style.height.slice(0, -2);\n            arr[idx2].innerHTML = arr[idx2].style.height.slice(0, -2);\n            arr[idx1].style.backgroundColor = colors.red;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            arr[idx2].style.backgroundColor = colors.purple;\n            if (i === animations.length - 1 || typeof animations[i + 1][1] !== 'number') {\n                cardFlip.play();\n                await wait(animationInterval);\n                arr[idx1].style.backgroundColor = colors.purple;\n            }\n        }\n        // Color an element\n        else {\n            const [idx, color] = animations[i];\n            arr[idx].style.backgroundColor = color;\n            await wait(animationInterval);\n        }\n    }\n}\n","const purple = '#8a2be2';\n// Based on array size\nconst gradients = {\n  3: { 1: '#00747f', 2: '#0073e7', 4: purple },\n  4: { 1: '#007264', 2: '#0076b8', 4: '#006cf5', 8: purple },\n  5: { 1: '#007056', 2: '#007596', 4: '#0075d7', 8: '#0066f9', 16: purple },\n  6: { 1: '#006f4d', 2: '#00747f', 4: '#0076b8', 8: '#0073e7', 16: '#0061fa', 32: purple },\n  7: { 1: '#006e47', 2: '#00736f', 4: '#0076a0', 8: '#0076cf', 16: '#0070f0', 32: '#005df9', 64: purple }\n};\n\n// Executes sorting algorithm and determines the sequence of animations\nexport default function getMergeAnimations(a) {\n  const animations = [], b = [];\n  const level = Math.ceil(Math.log2(a.length))\n\n  for (let width = 1; width < a.length; width *= 2) {\n    const color = gradients[level][width];\n    // Play card flip sound effect\n    animations.push(null);\n    \n    for (let i = 0; i < a.length; i += 2 * width) {\n      mergeAnimate(a, i, Math.min(i + width, a.length), Math.min(i + 2*width, a.length), b, animations, color);\n    }\n    for (let i = 0; i < a.length; i++) {\n      a[i] = b[i];\n    }\n  }\n  return animations\n}\n\nfunction mergeAnimate(a, left, right, end, b, animations, color) {\n  let i = left, j = right;\n  for (let k = left; k < end; k++) {\n    if (i < right && (j >= end || a[i] <= a[j])) {\n      // arr[i] = color\n      animations.push([color, i]);\n      b[k] = a[i++];\n    }\n    else {\n      // Swap two elements\n      animations.push([color, k, j]);\n      b[k] = a[j++];\n    }\n  }\n}\n\n\n// Original merge sort algorithm\n// export function mergeAlgo(a) {\n//   const b = [];\n\n//   for (let width = 1; width < a.length; width *= 2) {\n//     for (let i = 0; i < a.length; i += 2 * width) {\n//       merge(a, i, Math.min(i + width, a.length), Math.min(i + 2*width, a.length), b);\n//     }\n//     for (let i = 0; i < a.length; i++) {\n//       a[i] = b[i];\n//     }\n//   }\n\n//   return a;\n// }\n\n// function merge(a, left, right, end, b) {\n//   let i = left, j = right;\n  \n//   for (let k = left; k < end; k++) {\n//     if (i < right && (j >= end || a[i] <= a[j])) {\n//       b[k] = a[i++];\n//     }\n//     else {\n//       b[k] = a[j++];\n//     }\n//   }\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getMergeAnimations from '../algorithms/Merge';\n\n// Render merge sort animations\nexport default async function animateMergeSort(stateArray) {\n    const animations = getMergeAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // New merge iteration\n        if (!animations[i]) {\n            cardFlip.play();\n        }\n        // Swap two elements\n        else if (animations[i].length === 3) {\n            const [color, idx1, idx2] = animations[i];\n\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            const temp = arr[idx2].style.height;\n            for (let i = idx2; i > idx1; i--) {\n                arr[i].style.height = arr[i - 1].style.height;\n                arr[i].innerHTML = arr[i].style.height.slice(0, -2);\n            }\n            arr[idx1].style.height = temp;\n            arr[idx1].innerHTML = arr[idx1].style.height.slice(0, -2);\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = color;\n            await wait(animationInterval);\n\n            arr[idx1].style.backgroundColor = color;\n            await wait(animationInterval);\n        }\n        // Color one element\n        else {\n            const [color, idx] = animations[i];\n            arr[idx].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            arr[idx].style.backgroundColor = color;\n            await wait(animationInterval);\n        }\n    }\n}\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getQuickAnimations(arr, left, right, animations) {\n    let index;\n    if (arr.length > 1) {\n        index = partitionAnimate(arr, left, right, animations);\n        if (left < index - 1) {\n            getQuickAnimations(arr, left, index - 1, animations);\n        }\n        if (index < right) {\n            getQuickAnimations(arr, index, right, animations);\n        }\n    }\n    return animations;\n}\n\nfunction partitionAnimate(arr, left, right, animations) {\n    const pivotIdx = Math.floor((right + left) / 2)\n    const pivot = arr[pivotIdx];\n    // Color the pivot element red\n    animations.push([pivotIdx])\n    \n    let i = left;\n    let j = right;\n\n    while (i <= j) {\n        while (arr[i] < pivot) {\n            i++;\n        }\n        while (arr[j] > pivot) {\n            j--;\n        }\n        if (i <= j) {\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n            // Swap arr[i], arr[j]\n            animations.push([i, j])\n            i++;\n            j--;\n        }\n    }\n    return i;\n}\n\n\n// Original quicksort algorithm\n// export function quickAlgo(arr, left, right) {\n//     let index;\n//     if (arr.length > 1) {\n//         index = partition(arr, left, right);\n//         if (left < index - 1) { // more elements on the left side of the pivot\n//             quickAlgo(arr, left, index - 1);\n//         }\n//         if (index < right) { // more elements on the right side of the pivot\n//             quickAlgo(arr, index, right);\n//         }\n//     }\n//     return arr;\n// }\n\n// function partition(arr, left, right) {\n//     const pivot = arr[Math.floor((right + left) / 2)];\n    \n//     let i = left;\n//     let j = right;\n\n//     while (i <= j) {\n//         while (arr[i] < pivot) {\n//             i++;\n//         }\n//         while (arr[j] > pivot) {\n//             j--;\n//         }\n//         if (i <= j) {\n//             [arr[i], arr[j]] = [arr[j], arr[i]];\n//             i++;\n//             j--;\n//         }\n//     }\n//     return i;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getQuickAnimations from '../algorithms/Quick';\n\n// Render quick sort animations\nexport default async function animateQuickSort(stateArray) {\n    const animations = getQuickAnimations(stateArray, 0, stateArray.length - 1, []);\n    const arr = document.getElementsByClassName('array');\n    stateArray.sort((a, b) => a - b);\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // Select new pivot\n        if (animations[i].length === 1) {\n            cardFlip.play();\n            const [idx] = animations[i];\n\n            arr[idx].style.backgroundColor = colors.red;\n            await wait(animationInterval + 10);\n        }\n        // Swap two elements\n        else {\n            const [idx1, idx2] = animations[i];\n\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval + 10);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            arr[idx1].innerHTML = arr[idx1].style.height.slice(0, -2);\n            arr[idx2].innerHTML = arr[idx2].style.height.slice(0, -2);\n            await wait(animationInterval + 10);\n\n            const value1 = parseInt(arr[idx1].innerHTML);\n            const value2 = parseInt(arr[idx2].innerHTML);\n            arr[idx1].style.backgroundColor = value1 === stateArray[idx1] ? colors.purple : colors.green;\n            arr[idx2].style.backgroundColor = value2 === stateArray[idx2] ? colors.purple : colors.green;\n            await wait(animationInterval + 10);\n        }\n    }\n\n    arr[arr.length - 1].style.backgroundColor = colors.purple;\n}\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getHeapAnimations(arr) {\n    const animations = [];\n    const len = arr.length\n    let i  = Math.floor(len / 2 - 1);\n    // Last index of heap\n    let j = len - 1;\n\n    while (i >= 0) {\n        heapifyAnimate(arr, len, i, animations);\n        i--;\n    }\n\n    while (j >= 0) {\n        [arr[0], arr[j]] = [arr[j], arr[0]];\n        // Swap arr[0], arr[j]\n        animations.push([0, j])\n        heapifyAnimate(arr, j, 0, animations);\n        j--;\n    }\n    \n    return animations;\n}\n\nfunction heapifyAnimate(arr, len, i, animations) {\n    let largest = i;\n    const left = i * 2 + 1;\n    const right = left + 1;\n\n    if (left < len && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    if (right < len && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    if (largest !== i) {\n        [arr[i], arr[largest]] = [arr[largest], arr[i]];\n        // Swap arr[i], arr[largest]\n        animations.push([i, largest, true])\n        heapifyAnimate(arr, len, largest, animations);\n    }\n}\n\n\n// // Original heap sort algorithm\n// export function heapAlgo(arr) {\n//     const len = arr.length\n//     let i  = Math.floor(len / 2 - 1);\n//     // Last index of heap\n//     let j = len - 1;\n\n//     while (i >= 0) {\n//         heapify(arr, len, i);\n//         i--;\n//     }\n\n//     while (j >= 0) {\n//         [arr[0], arr[j]] = [arr[j], arr[0]];\n//         heapify(arr, j, 0);\n//         j--;\n//     }\n    \n//     return arr;\n// }\n\n// function heapify(arr, len, i) {\n//     let largest = i;\n//     const left = i * 2 + 1;\n//     const right = left + 1;\n\n//     if (left < len && arr[left] > arr[largest]) {\n//         largest = left;\n//     }\n//     if (right < len && arr[right] > arr[largest]) {\n//         largest = right;\n//     }\n\n//     if (largest !== i) {\n//         [arr[i], arr[largest]] = [arr[largest], arr[i]];\n//         heapify(arr, len, largest);\n//     }\n// }\n","import { cardFlip, cardFlip2, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getHeapAnimations from '../algorithms/Heap';\n\n// Render heap sort animations\nexport default async function animateHeapSort(stateArray) {\n    const animations = getHeapAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    let playCount = 0;\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // Only procedure is swapping\n        const [idx1, idx2, isGreen] = animations[i];\n        arr[idx1].style.backgroundColor = colors.yellow;\n        arr[idx2].style.backgroundColor = colors.yellow;\n        await wait(animationInterval);\n\n        [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n        arr[idx1].innerHTML = arr[idx1].style.height.slice(0, -2);\n        arr[idx2].innerHTML = arr[idx2].style.height.slice(0, -2);\n        await wait(animationInterval);\n        \n        arr[idx1].style.backgroundColor = colors.green;\n        if (isGreen) {\n            if (++playCount === 2) {\n                playCount = 0;\n                cardFlip.play();\n            }\n            arr[idx2].style.backgroundColor = colors.green;\n        }\n        else {\n            playCount = 4;\n            cardFlip2.play();\n            arr[idx2].style.backgroundColor = colors.purple;\n        }\n        await wait(animationInterval);\n    }\n}","// Executes sorting algorithm and determines the sequence of animations\nexport default function getShellAnimations(arr) {\n    const animations = [];\n\n    const len = arr.length;\n    for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n        // Play card flip\n        animations.push(null);\n        for (let i = gap; i < len; i++) {\n            const temp = arr[i];\n            // arr[i] = purple\n            animations.push([i]);\n            for (let j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                [arr[j], arr[j - gap]] = [arr[j - gap], arr[j]];\n                // Swap arr[j], arr[j - gap]\n                animations.push([j - gap, j]);\n            }\n        }\n    }\n    \n    return animations;\n}\n\n\n// Original shell algo w/ more swapping for better visual\n// export function shellAlgo(arr) {\n//     const len = arr.length;\n//     for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n//         for (let i = gap; i < len; i++) {\n//             const temp = arr[i];\n//             for (let j = i; j >= gap && arr[j-gap] > temp; j -= gap) {\n//                 [arr[j], arr[j-gap]] = [arr[j-gap], arr[j]];\n//             }\n//         }\n//     }\n//     return arr;\n// }\n\n// More efficient version - less swapping\n// export function shellAlgo2(arr) {\n//     const len = arr.length;\n//     let gap = Math.floor(len / 2);\n//     while (gap > 0) {\n//         for (let i = gap; i < len; i++) {\n//             const temp = arr[i];\n//             let j = i;\n//             while (j >= gap && arr[j-gap] > temp) {\n//                 arr[j] = arr[j-gap];\n//                 j -= gap;\n//             }\n//             arr[j] = temp;\n//         }\n//         gap = Math.floor(gap / 2);\n//     }\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getShellAnimations from '../algorithms/Shell';\n\n// Render shell sort animations\nexport default async function animateShellSort(stateArray) {\n    const animations = getShellAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // New iteration\n        if (animations[i] === null) {\n            cardFlip.play();\n        }\n        // Swap two elements\n        else if (animations[i].length > 1) {\n            // cardFlip.play();\n            const [idx1, idx2] = animations[i];\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            arr[idx1].innerHTML = arr[idx1].style.height.slice(0, -2);\n            arr[idx2].innerHTML = arr[idx2].style.height.slice(0, -2);\n            await wait(animationInterval);\n            \n            const value1 = parseInt(arr[idx1].innerHTML);\n            const value2 = parseInt(arr[idx2].innerHTML);\n            arr[idx1].style.backgroundColor = value1 === stateArray[idx1] ? colors.purple : colors.green;\n            arr[idx2].style.backgroundColor = value2 === stateArray[idx2] ? colors.purple : colors.green;\n            await wait(animationInterval);\n        }\n        // Color an element\n        else {\n            const [idx] = animations[i];\n            const oldColor = arr[idx].style.backgroundColor;\n            arr[idx].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n            arr[idx].style.backgroundColor = oldColor;\n            await wait(animationInterval);\n        }\n    }\n}\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getCountingAnimations(arr) {\n    const animations = [];\n    const max = Math.max(...arr);\n    const min = Math.min(...arr);\n\n    let i = min;\n    let j = 0;\n    let count = [];\n\n    for (i; i <= max; i++) {\n        count[i] = 0;\n    }\n    for (i = 0; i < arr.length; i++) {\n        count[arr[i]]++;\n        const hue = mapToHue(arr[i], min, max);\n        animations.push([i, hue]);\n    }\n\n    for (i = min; i <= max; i++) {\n        while (count[i] > 0) {\n            arr[j] = i;\n            const hue = mapToHue(i, min, max);\n            animations.push([j, i, hue]);\n            j++;\n            count[i]--;\n        }\n    }\n    \n    return animations;\n}\n\n// Maps a value to the 0-270 range on the hue wheel\nfunction mapToHue(value, min, max) {\n    return 270 * (value - min) / (max - min);\n}\n\n\n// Original counting sort algorithm\n// export function countingAlgo(arr) {\n//     max = Math.max(...arr);\n//     min = Math.min(...arr);\n//     let i = min;\n//     let j = 0;\n//     let count = [];\n\n//     for (i; i <= max; i++) {\n//         count[i] = 0;\n//     }\n//     for (i = 0; i < arr.length; i++) {\n//         count[arr[i]]++;\n//     }\n\n//     for (i = min; i <= max; i++) {\n//         while (count[i] > 0) {\n//             arr[j] = i;\n//             j++;\n//             count[i]--;\n//         }\n//     }\n\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport { barFade } from '../components/SortingHelpers';\nimport getCountingAnimations from '../algorithms/Counting';\n\n// Render heap sort animations\nexport default async function animateCountingSort(stateArray) {\n    const animations = getCountingAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    \n    // Color array elements according to their value\n    let i = 0;\n    for (i; i < animations.length / 2; i++) {\n        if (!isRunning) return;\n\n        const [idx, hue] = animations[i];\n        arr[idx].style.backgroundColor = `hsl(${hue}, 100%, 45%)`;\n        await wait(animationInterval + 10);\n    }\n    await wait(500);\n\n    // Sorting step\n    for (i; i < animations.length; i++) {\n        if (!isRunning) return;\n        const [idx, height, hue] = animations[i];\n        if (arr[idx].style.height !== height + 'px') {\n            cardFlip.play();\n            arr[idx].style.height = height + 'px';\n            arr[idx].innerHTML = arr[idx].style.height.slice(0, -2);\n        }\n        arr[idx].style.backgroundColor = `hsl(${hue}, 100%, 45%)`;\n\n        await wait(animationInterval + 10);\n    }\n    if (!isRunning) return;\n    await wait(500);\n    for (let i = 0; i < arr.length; i++) {\n        if (!isRunning) return;\n        arr[i].style.backgroundColor = colors.purple;\n        await wait(500 / arr.length);\n    }\n    // await barFade();\n}\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getRadixAnimations(arr) {\n    const animations = [];\n\n    const digits = Math.max(...arr).toString().length;\n\tfor (let i = 0; i < digits; i++) {\n        const buckets = Array.from({ length: 10 }, () => []);\n\t\tfor (let j = 0; j < arr.length; j++) {\n            buckets[getDigit(arr[j], i)].push(arr[j]);\n        }\n        arr = buckets.flat();\n        for (let k = 0; k < arr.length; k++) {\n            const hue = valueToHue[getDigit(arr[k], i)];\n            animations.push([k, arr[k], hue]);\n        }\n\t}\n\n    return animations;\n}\n\n// Maps a value to the 0-270 range on the hue wheel\nconst valueToHue = {\n    0: 0, \n    1: 30, \n    2: 60, \n    3: 90, \n    4: 120, \n    5: 150, \n    6: 180, \n    7: 210, \n    8: 240, \n    9: 270\n}\n\n\n// Original radix sort algorithm\n// export function radixAlgo(arr) {\n//     const digits = Math.max(...arr).toString().length;\n// \tfor (let i = 0; i < digits; i++) {\n//         const buckets = Array.from({ length: 10 }, () => []);\n// \t\tfor (let j = 0; j < arr.length; j++) {\n//             buckets[getDigit(arr[j], i)].push(arr[j]);\n            \n//         }\n//         arr = buckets.flat()\n// \t}\n//     return arr;\n// }\n\nfunction getDigit(num, place) {\n    return Math.floor(num / Math.pow(10, place)) % 10;\n}\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getRadixAnimations from '../algorithms/Radix';\n\n// Render heap sort animations\nexport default async function animateRadixSort(stateArray) {\n    const animations = getRadixAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        const [idx, height, hue] = animations[i];\n        if (arr[idx].style.height !== height + 'px') {\n            cardFlip.play();\n            arr[idx].style.height = height + 'px';\n            arr[idx].innerHTML = arr[idx].style.height.slice(0, -2);\n        }\n        arr[idx].style.backgroundColor = `hsl(${hue}, 100%, 45%)`;\n\n        await wait(animationInterval + 10);\n        if (idx === arr.length - 1 && i !== animations.length - 1) {\n            await wait(300);\n            for (let j = 0; j < arr.length; j++) {\n                arr[j].style.backgroundColor = colors.green;\n            }\n            await wait(100);\n        }\n    }\n    await wait(500);\n    for (let i = 0; i < arr.length; i++) {\n        arr[i].style.backgroundColor = colors.purple;\n        await wait(500 / arr.length);\n    }\n}\n","import { insertionAlgo } from './Insertion';\n// Executes sorting algorithm and determines the sequence of animations\nexport default function getBucketAnimations(arr) {\n    const animations = [];\n\n    const size = arr.length - 1;\n    let min = Math.min(...arr);\n    let max = Math.max(...arr);\n\n    const len = Math.floor((max - min) / size) + 1;\n    const buckets = [...new Array(len)].map(() => []);\n\n    for (let i = 0; i < arr.length; i++) {\n        buckets[Math.floor((arr[i] - min) / size)].push(arr[i]);\n    }\n\n    const tempArr = buckets.flat();\n    for (let i = 0; i < tempArr.length; i++) {\n        const value = Math.floor(i * 10 / arr.length);\n        const hue = valueToHue[value];\n        animations.push([i, tempArr[i], hue]);\n    }\n\n    arr.length = [];\n    buckets.forEach(bucket => {\n        insertionAlgo(bucket);\n        bucket.forEach(element => arr.push(element));\n    });\n\n    return animations;\n}\n\n// Maps a value to the 0-270 range on the hue wheel\nconst valueToHue = {\n    0: 0, \n    1: 30, \n    2: 60, \n    3: 90, \n    4: 120, \n    5: 150, \n    6: 180, \n    7: 210, \n    8: 240, \n    9: 270\n}\n\n\n\n// Original bucket sort algorithm\nexport function bucketAlgo(arr) {\n    const size = 10;\n    let min = Math.min(...arr);\n    let max = Math.max(...arr);\n\n    const len = Math.floor((max - min) / size) + 1;\n    const buckets = [...new Array(len)].map(() => []);\n\n    for (let i = 0; i < arr.length; i++) {\n        const bucket = Math.floor((arr[i] - min) / size);\n        buckets[bucket].push(arr[i]);\n    }\n\n    arr.length = [];\n    buckets.forEach(bucket => {\n        insertionAlgo(bucket);\n        bucket.forEach(element => arr.push(element));\n    });\n\n    return arr;\n}\n","import { cardFlip, wait, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getBucketAnimations from '../algorithms/Bucket';\nimport animateInsertionSort from '../animations/InsertionAnimation';\n\n// Render heap sort animations\nexport default async function animateBucketSort(stateArray) {\n    const animations = getBucketAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        \n        const [idx, height, hue] = animations[i];\n        if (arr[idx].style.height !== height + 'px') {\n            cardFlip.play();\n            arr[idx].style.height = height + 'px';\n            arr[idx].innerHTML = arr[idx].style.height.slice(0, -2);\n        }\n        arr[idx].style.backgroundColor = `hsl(${hue}, 100%, 45%)`;\n\n        await wait(animationInterval + 5);\n    }\n\n    const newArr = []\n    for (let i = 0; i < arr.length; i++) {\n        newArr.push(parseInt(arr[i].style.height.slice(0, -2)));\n    }\n    \n    await animateInsertionSort(newArr);\n}\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getBubbleAnimations(arr) {\n    const animations = [];\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                // Swap arr[j], arr[j + 1]\n                animations.push([j, j + 1]);\n            }\n        }\n    }\n    return animations;\n}\n\n\n// Original bubble sort algorithm\n// export function bubbleAlgo(arr) {\n//     for (let i = 0; i < arr.length; i++) {\n//         for (let j = 0; j < arr.length; j++) {\n//             if (arr[j] > arr[j + 1]) {\n//                 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n//             }\n//         }\n//     }\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getBubbleAnimations from '../algorithms/Bubble';\n\n// Render bubble sort animations\nexport default async function animateBubbleSort(stateArray) {\n    const animations = getBubbleAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // Only operation is swapping\n        const [idx1, idx2] = animations[i];\n        arr[idx1].style.backgroundColor = colors.yellow;\n        arr[idx2].style.backgroundColor = colors.yellow;\n        await wait(animationInterval);\n\n        [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n        arr[idx1].innerHTML = arr[idx1].style.height.slice(0, -2);\n        arr[idx2].innerHTML = arr[idx2].style.height.slice(0, -2);\n        await wait(animationInterval);\n        \n        const value1 = parseInt(arr[idx1].innerHTML);\n        const value2 = parseInt(arr[idx2].innerHTML);\n        arr[idx1].style.backgroundColor = value1 === stateArray[idx1] ? colors.purple : colors.green;\n        if (value2 === stateArray[idx2]) {\n            cardFlip.play();\n            arr[idx2].style.backgroundColor = colors.purple;\n        }\n        else {\n            arr[idx2].style.backgroundColor = colors.green;\n        }\n        \n        await wait(animationInterval);\n    }\n}\n\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getCombAnimations(arr) {\n    const animations = [];\n    const interval = 1.3;\n    let iteration = 0;\n    let gap = arr.length - 2;\n   \n    while (!isSorted(arr)) {\n        // Plays card flip\n        animations.push(null);\n        if (iteration) {\n           gap = gap === 1 ? gap : Math.floor(gap / interval);\n        }\n\n        let front = 0;\n        for (let back = gap; back <= arr.length - 1; back++) {\n            if (arr[front] > arr[back]) {\n                [arr[front], arr[back]] = [arr[back], arr[front]];\n                // Swap arr[front], arr[back]\n                animations.push([front, back]);\n            }\n            front++;\n        }\n        iteration++;\n    }\n\n    return animations;\n}\n\nfunction isSorted(arr) {\n    for (var i = 0; i < arr.length - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            return false\n        }\n    }\n    return true;\n}\n\n\n// Original comb sort algorithm\n// export function combAlgo(arr) {\n//     const interval = 1.3;\n//     let iteration = 0;\n//     let gap = arr.length - 2;\n   \n//     while (!isSorted(arr)) {\n//         if (iteration) {\n//            gap = gap === 1 ? gap : Math.floor(gap / interval);\n//         }\n   \n//         let front = 0;\n//         for (let back = gap; back <= arr.length - 1; back++) {\n//             if (arr[front] > arr[back]) {\n//                 [arr[front], arr[back]] = [arr[back], arr[front]];\n//             }\n//             front++;\n//         }\n//         iteration++;\n//     }\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getCombAnimations from '../algorithms/Comb';\n\n// Render comb sort animations - very similar to bubble sort\nexport default async function animateCombSort(stateArray) {\n    const animations = getCombAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // New iteration\n        if (animations[i] === null) {\n            cardFlip.play();\n        }\n        // Swapping two elements\n        else {\n            const [idx1, idx2] = animations[i];\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval + 10);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            arr[idx1].innerHTML = arr[idx1].style.height.slice(0, -2);\n            arr[idx2].innerHTML = arr[idx2].style.height.slice(0, -2);\n            await wait(animationInterval + 10);\n            \n            const value1 = parseInt(arr[idx1].innerHTML);\n            const value2 = parseInt(arr[idx2].innerHTML);\n            arr[idx1].style.backgroundColor = value1 === stateArray[idx1] ? colors.purple : colors.green;\n            arr[idx2].style.backgroundColor = value2 === stateArray[idx2] ? colors.purple : colors.green;\n        }   \n        await wait(animationInterval + 10);\n    }\n}\n","import { colors, wait, isReset } from './SortingTimeVisualizer';\nexport {default as selection} from '../animations/SelectionAnimation';\nexport {default as insertion} from '../animations/InsertionAnimation';\nexport {default as merge} from '../animations/MergeAnimation';\nexport {default as quick} from '../animations/QuickAnimation';\nexport {default as heap} from '../animations/HeapAnimation';\nexport {default as shell} from '../animations/ShellAnimation';\nexport {default as counting} from '../animations/CountingAnimation';\nexport {default as radix} from '../animations/RadixAnimation';\nexport {default as bucket} from '../animations/BucketAnimation';\nexport {default as bubble} from '../animations/BubbleAnimation';\nexport {default as comb} from '../animations/CombAnimation';\n\n//* Helpers *//\n// For testing purposes\nexport const arrayEquality = (a, b) => {\n\tif (a.length !== b.length) {\n        return false;\n    }\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Generates many large arrays, logs 'true' for each correct sort\nexport const testSort = mySort => {\n    const startTime = new Date();\n    for (let i = 0; i < 100; i++) {\n        let testArr = [];\n        const length = Math.floor(Math.random()*1001 + 5);\n        for (let j = 0; j < length; j++) {\n            testArr.push(Math.floor(Math.random()*501));\n        }\n        const testArr2 = [...testArr];\n\n        testArr = mySort(testArr);  \n        testArr2.sort((a, b) => a - b);\n        console.log(arrayEquality(testArr, testArr2));\n    }\n    const elapsedTime = new Date() - startTime;\n    console.log('Elapsed time: ', elapsedTime, ' ms');\n}\n\n// For menu color fading - based on average case\nexport const menuColors = {\n    purple: 270,   // Initial\n    red: 5,        // O(n^2)\n    redOrange: 18, // In between\n    orange: 28,    // O(nlogn)\n    yellow: 45,    // O(n) possibly\n};\n\nexport const algoColors = {\n    selection: menuColors.red,\n    insertion: menuColors.red,\n    merge: menuColors.orange,\n    quick: menuColors.orange,\n    heap: menuColors.orange,\n    shell: menuColors.redOrange,\n    counting: menuColors.yellow,\n    radix: menuColors.yellow,\n    bucket: menuColors.yellow,\n    bubble: menuColors.red,\n    comb: menuColors.redOrange\n};\n\n// Linear interpolation\nexport const lerp = (a,b,u) => {\n    return (1-u) * a + u * b;\n}\n\n// Transition color theme\nexport const themeFade = async (start, end) => {\n    const duration = 1500;\n    const interval = 10;\n    const step_u = interval / duration;\n    const menu = document.getElementById('menu-container').style;\n    const icon = document.querySelector('.info-icon').style;\n    const infoButton = document.getElementById('info-button').style;\n    for (let u = 0.0; u < 1.0; u += step_u) {\n        const hue = lerp(start, end, u);\n        menu.setProperty('background-color', `hsl(${hue}, 95%, 35%)`);\n        menu.setProperty('box-shadow', `-1.5px 1.5px 2.5px hsl(${hue}, 95%, 15%)`);\n        icon.setProperty('color',`hsl(${hue}, 95%, 20%)`)\n        infoButton.setProperty('border-color', `hsl(${hue}, 95%, 25%)`);\n        infoButton.setProperty('background-color', `hsla(${hue}, 95%, 30%, 0.1)`);\n        await wait(interval);\n    }\n};\n\n// Change array color to green\nexport const getMenuHue = () => {\n    const menu = document.getElementById('menu-container');\n    const color = menu.style.backgroundColor.match(/\\d+/g)?.map(Number);\n    if (!color) return menuColors.purple;\n    const [r, g, b] = [color[0]/255, color[1]/255, color[2]/255];\n    const max = Math.max(r, g, b), min = Math.min(r, g, b);\n    let hue = 0;\n    if (max !== min) {\n        const d = max - min;\n        switch (max) {\n            case r: hue = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: hue = (b - r) / d + 2; break;\n            case b: hue = (r - g) / d + 4; break;\n            default: break;\n        }\n    }\n    return hue * 60;\n};\n\nexport const barFade = async () => {\n    await wait(500);\n    if (isReset) return;\n    const arr = document.getElementsByClassName('array');\n    const duration = 1000;\n    const interval = 10;\n    const start = hexToRgb(colors.purple);\n    const end = hexToRgb(colors.green);\n    const step_u = interval / duration;\n\n    for (let u = 0.0; u < 1.0; u += step_u) {\n        if (isReset) return;\n        const r = lerp(start.r, end.r, u);\n        const g = lerp(start.g, end.g, u);\n        const b = lerp(start.b, end.b, u);\n        for (let i = 0; i < arr.length; i++) {\n            arr[i].style.setProperty('background-color', `rgb(${r},${g},${b})`);\n        }\n        await wait(interval);\n    }\n};\n\nexport function hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n    } : null;\n}\n","import React from 'react';\nimport Button from '@material-ui/core/Button';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport Slide from '@material-ui/core/Slide';\nimport MenuBookIcon from '@material-ui/icons/MenuBook';\nimport info from './Info';\nimport { algoColors } from './SortingHelpers';\nimport ReactHtmlParser from 'react-html-parser';\nimport '../css/SortingTimeVisualizer.css';\n\nconst Transition = React.forwardRef(function Transition(props, ref) {\n  return <Slide direction='left' ref={ref} {...props} />;\n});\n\nexport default function InfoBox(props) {\n  const text = info[props.algorithm];\n  const hue = algoColors[props.algorithm];\n  const styles = {\n    button: {\n      margin: 'auto',\n      borderRadius: '10%',\n    },\n    icon: {\n      fontSize: 75,\n      color: 'black',\n      position: 'relative',\n      bottom: '2px'\n    },\n    header: {\n      textAlign: 'center',\n      display: 'block',\n      color: `hsla(${hue}, 95%, 10%, 0.94)`,\n      fontSize: 35,\n      fontWeight: 800,\n    },\n    bold: {\n      fontSize: 16,\n      fontWeight: 600,\n      display: 'block',\n    },\n    normal: {\n      fontWeight: 500\n    },\n    algo: {\n      fontSize: 15,\n      fontWeight: 500,\n      fontFamily: `FiraCode`\n    },\n    paper: {\n      color: `hsla(${hue}, 95%, 5%, 0.94)`,\n      backgroundColor: `hsla(${hue}, 25%, 63%, 0.96)`,\n      maxHeight: `50vh`,\n      minWidth: `40vh`,\n      // maxWidth: `45vh`,\n      fontFamily: `Arial`\n    },\n    subHeader: {\n      textAlign: 'center',\n      display: 'block',\n      marginTop: 5,\n      marginBottom: 5,\n      textDecoration: `underline hsla(${hue}, 95%, 10%, 0.94)`\n    },\n    exit: {\n      fontSize: 14,\n      fontWeight: 500,\n      color: `hsla(${hue}, 95%, 10%, 0.94)`\n    }\n  };\n\n  const [open, setOpen] = React.useState(false);\n  \n  const handleClickOpen = () => setOpen(true);\n  const handleClose = () => setOpen(false);\n\n  return (\n    <div id='info-box-container' style={styles.container}>\n        <Button id='info-button' variant='outlined' color='primary' onClick={handleClickOpen} style={styles.button}>\n            <MenuBookIcon className='info-icon' style={styles.icon}/>\n        </Button>\n        <Dialog\n          PaperProps={{style: styles.paper}}\n          style={styles.dialog}\n          scroll='paper'\n          open={open}\n          TransitionComponent={Transition}\n          keepMounted\n          onClose={handleClose}\n          aria-labelledby='alert-dialog-slide-title'\n          aria-describedby='alert-dialog-slide-description'\n        >\n          <DialogTitle id='alert-dialog-slide-title'>\n            <span id='info-header' style={styles.header}>\n              {text.header}\n            </span>\n          </DialogTitle>\n          <DialogContent>\n            <DialogContentText id='alert-dialog-slide-description'>\n              <span id='info-body' style={styles.paper}>\n                <span style={styles.subHeader}>Time Complexity</span>\n                <span style={styles.bold}>Best case:\n                  <span style={styles.normal}> &Omega;({ReactHtmlParser(text.best)})</span>\n                </span>\n                <span style={styles.bold}>Average case:\n                  <span style={styles.normal}> &Theta;({ReactHtmlParser(text.avg)})</span>\n                </span>\n                <span style={styles.bold}>Worst case:\n                  <span style={styles.normal}> O({ReactHtmlParser(text.worst)})</span>\n                </span>\n                <span style={styles.bold}>Space complexity:\n                  <span style={styles.normal}> O({ReactHtmlParser(text.space)})<br/><br/></span>\n                </span>\n                <span style={styles.subHeader}>Algorithm (JavaScript)</span>\n                <span style={styles.bold}> \n                  <span style={styles.algo}> {ReactHtmlParser(text.algo)}</span>\n                </span>\n              </span>\n            </DialogContentText>\n          </DialogContent>\n          <DialogActions>\n            <Button onClick={handleClose} style={styles.exit}>\n              X\n            </Button>\n          </DialogActions>\n        </Dialog>\n    </div>\n  );\n}\n","import React from 'react';\nimport '../css/Timer.css';\n// https://github.com/peterdurham/timers-demo\n\nexport default class Timer extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            status: this.props.status,\n            timeStart: 0,\n            time: 0\n        };\n    }\n\n    // Starts whenever 'Execute' button is pressed\n    startTimer = () => {\n        this.setState({\n            status: true,\n            timeStart: Date.now() - this.state.time,\n            time: this.state.time\n        });\n        this.timer = setInterval(() => {\n            this.setState({ time: Date.now() - this.state.timeStart });\n        }, 10);\n    }\n\n    stopTimer = () => {\n        this.setState({ status: false });\n        clearInterval(this.timer);\n    }\n\n    resetTimer = () => {\n        this.setState({\n            timeStart: 0,\n            time: 0\n        });\n    }\n\n    setStatus = bool => {\n        if (bool) {\n            if (this.state.status) return;\n            this.resetTimer();\n            // Timer won't reset if this isn't in a setTimeout\n            setTimeout(() => this.startTimer(), 0);\n        }\n        else {\n            this.stopTimer();\n        }\n    }\n    \n    render = () => {\n        const { time } = this.state;\n        const centiseconds = ('0' + (Math.floor(time / 10) % 100)).slice(-2);\n        const seconds = ('0' + (Math.floor(time / 1000) % 60)).slice(-2);\n        const minutes = ('0' + (Math.floor(time / 60000) % 60)).slice(-2);\n        return (\n            <span id='timer-container' className='noselect'>\n                <span className='timer timer-icon'>\n                    <svg version='1.1' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 296.228 296.228' enableBackground='new 0 0 296.228 296.228'>\n                        <g>\n                            <path d='m167.364,48.003v-23.003h10.5c6.903,0 12.5-5.597 12.5-12.5s-5.596-12.5-12.5-12.5h-59.5c-6.903,0-12.5,5.597-12.5,12.5s5.597,12.5 12.5,12.5h10.5v23.003c-59.738,9.285-105.604,61.071-105.604,123.37-3.55271e-15,68.845 56.01,124.854 124.854,124.854s124.854-56.01 124.854-124.854c0-62.299-45.866-114.085-105.604-123.37zm-19.25,223.225c-55.06,0-99.854-44.795-99.854-99.854s44.795-99.854 99.854-99.854 99.854,44.795 99.854,99.854-44.794,99.854-99.854,99.854z'/>\n                            <path d='m160.614,166.18v-58.889c0-6.903-5.597-12.5-12.5-12.5s-12.5,5.597-12.5,12.5v66.1c0,2.033 0.81,3.982 2.25,5.416l34.969,34.822c4.893,4.872 12.806,4.854 17.678-0.037 4.871-4.892 4.854-12.807-0.037-17.678l-29.86-29.734z'/>\n                        </g>\n                    </svg>\n                </span>\n                <span className='timer timer-display'>\n                    <span id='seconds'>{minutes}:{seconds}</span>\n                    <span id='centiseconds'>{centiseconds}</span>\n                </span>\n            </span>\n      );\n    }\n  }\n","import React from 'react';\nimport Menu from './Menu';\nimport InfoBox from './InfoBox';\nimport Timer from './Timer';\nimport UIfx from 'uifx';\nimport cardFlipMp3 from '../resources/card-flip.mp3';\nimport cardFlip2Mp3 from '../resources/card-flip-2.mp3';\nimport '../css/SortingTimeVisualizer.css';\nimport * as help from './SortingHelpers';\n\n// These are passed to animation/algorithm scripts that execute the sort\nexport let isRunning = false;\nexport let isReset = false;\nexport let animationInterval = 0;\nexport const cardFlip = new UIfx(cardFlipMp3, { throttleMs: 60, volume: 0.7 });\nexport const cardFlip2= new UIfx(cardFlip2Mp3,{ throttleMs: 80,volume: 0.6 });\nexport const colors = {\n    purple: '#8a2be2',\n    red: '#dc143c',\n    green: '#24682d',\n    yellow: '#ffff00',\n};\n\n// Effectively a synchronous sleep function\nexport const wait = ms => {\n    return new Promise(res => setTimeout(res, ms));\n}\n\n//* Main component of application *//\nexport default class SortingTimeVisualizer extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            array: [],\n            bars: [],\n            algorithm: 'selection'\n        };\n        \n        this.storedArray = [];\n        this.defaultLength = 60;\n        this.maxHeight = 550;\n        this.timerElement = React.createRef();\n    }\n\n    // Set heights\n    componentDidMount = () => {\n        this.maxHeight = Math.floor(0.9 * document.getElementById('bars-container').clientHeight);\n        document.getElementById('body-container').style.height = (document.body.clientHeight - document.getElementById('menu-container').getBoundingClientRect().bottom) + 'px';\n        this.selectAlgorithm('selection')\n    }\n    \n    // True if algorithm is currently running, false otherwise\n    setRunning = async bool => {\n        isRunning = bool;\n        this.timerElement.current.setStatus(bool);\n        if (bool) {\n            isReset = false;\n            document.getElementById('execute').classList.add('running');\n        } else {\n            document.getElementById('execute').classList.remove('running');\n        }\n    }\n\n    // Compute reciprocal of interval to make the slider feel linear\n    speedChange = interval => {\n        animationInterval = interval < 3 ? 500 : 1500/interval - 15;\n    }\n\n    // Display a new randomized array, possibly with a new length\n    generateArray = length => {\n        const array = document.getElementsByClassName('array');\n        isRunning && this.setRunning(false);\n        isReset = true;\n        let arraySize;\n        if (length) {\n            arraySize = length;\n            this.defaultLength = length;\n        } else {\n            arraySize = this.defaultLength;\n        }\n\n        // The constant values are arbitrary and were chosen because they look nice\n        const windowWidth = window.innerWidth;\n        const margin = Math.max((windowWidth) / (10 * arraySize), 1.5);\n        const width = Math.max((windowWidth - 100) / (1.75 * arraySize), 7);\n        const radius = Math.max(width / 10, 3);\n        \n        const newArray = [];\n        for (let i = 0; i < arraySize; i++) {\n            newArray.push(Math.floor(Math.random() * this.maxHeight + 50));\n        }\n        const newBars = newArray.map((value, i) => <div className='array noselect' key={i} idx={i} color={colors.green} type={undefined} style={{\n            height: value,\n            marginLeft: margin,\n            marginRight: margin,\n            width: width,\n            borderRadius: radius,\n            fontSize: width/2.5\n        }} >{value}</div>);\n        this.setState({\n            array: newArray,\n            bars: newBars\n        });\n\n        // Deep copy to allow resetting to original state\n        this.storedArray = [...newArray];\n\n        setTimeout(() => {\n            if (length > 50) {\n                for (let i = 0; i < array.length; i++) {\n                    array[i].style.backgroundColor = colors.green;\n                    array[i].style.color = 'rgba(0,0,0,0)';\n                }\n            }\n            else {\n                for (let i = 0; i < array.length; i++) {\n                    array[i].style.backgroundColor = colors.green;\n                    array[i].style.color = 'black';\n                }\n            }\n        }, 0)\n    }\n\n    // Return bar heights and colors to pre-sorted state\n    resetArray = async () => {\n        cardFlip.play()\n        const array = document.getElementsByClassName('array');\n        const arraySize = array.length;\n\n        this.setRunning(false);\n        isReset = true;\n\n        const oldArray = []\n        for (let i = 0; i < arraySize; i++) {\n            array[i].style.height = this.storedArray[i] + 'px';\n            array[i].innerHTML = array[i].style.height.slice(0, -2);\n            array[i].type = undefined;\n            oldArray.push(this.storedArray[i]);\n        }\n\n        this.setState({array: oldArray});\n        \n        for (let i = 0; i < arraySize; i++) {\n            array[i].style.backgroundColor = '#07ad1d';\n        }\n        await wait(350);\n        for (let i = 0; i < arraySize; i++) {\n            array[i].style.backgroundColor = colors.green;\n        }\n    }\n\n    // Response to selecting algorithm from dropdown\n    selectAlgorithm = async selection => {\n        this.setState({ algorithm: selection });\n        const oldHue = help.getMenuHue();\n        const newHue = help.algoColors[selection];\n        await help.themeFade(oldHue, newHue);\n    }\n\n    // Runs selected algorithm\n    handleExecute = async () => {\n        if (isRunning) return;\n        cardFlip.play(0);\n        this.setRunning(true);\n        const array = this.state.array;\n\n        switch (this.state.algorithm) {\n            case 'selection':  await help.selection(array);  break;\n            case 'insertion':  await help.insertion(array);  break;\n            case 'merge':      await help.merge(array);      break;\n            case 'quick':      await help.quick(array);      break;\n            case 'heap':       await help.heap(array);       break;\n            case 'shell':      await help.shell(array);      break;\n            case 'counting':   await help.counting(array);   break;\n            case 'radix':      await help.radix(array);      break;\n            case 'bucket':     await help.bucket(array);     break;\n            case 'bubble':     await help.bubble(array);     break;\n            case 'comb':       await help.comb(array);       break;\n            default: await help.selection(array);\n        }\n\n        // Sort the state array to match the bars\n        array.sort((a, b) => a - b);\n        const arr = document.getElementsByClassName('array');\n        for (let i = 0; i < array.length; i++) {\n            arr[i].style.height = array[i] + 'px';\n            arr[i].style.backgroundColor = colors.purple; \n        }\n        this.setRunning(false);\n        await help.barFade();\n    }\n\n    // Everything on screen is rendered here\n    render = () => {\n        return (\n            <div id='body-container'>\n                <div id='color-strip' />\n                <Menu onGenerate={this.generateArray} onReset={this.resetArray} onSpeedChange={this.speedChange} onExecute={this.handleExecute} onSelect={this.selectAlgorithm} />\n                <div id='body'>\n                    <div id='horizontal-container'>\n                        <div id='left-container' />\n                        <div id='bars-container'>\n                            <div id='bars-cell'>\n                                {this.state.bars}\n                                {/* Used for testing algorithms */}\n                                {/* <button id='test-sort' onClick={help.testSort.bind(this, combAlgo)}>Test Sort</button> */}\n                            </div>\n                        </div>\n                        <div id='right-container'>\n                            <InfoBox algorithm={this.state.algorithm} />\n                        </div>\n                    </div>\n                    <div id='bottom-container'>\n                        <Timer status={isRunning} ref={this.timerElement}/>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n","import React, { useEffect } from 'react';\nimport './css/App.css';\nimport SortingTimeVisualizer from './components/SortingTimeVisualizer';\nimport ReactGA from 'react-ga'; // https://github.com/react-ga/react-ga\n\n\nfunction App() {\n  // Google Analytics\n  useEffect(() => {\n    ReactGA.initialize('UA-174975160-2');\n    ReactGA.pageview(window.location.pathname);\n  }, []);\n\n  return (\n    <div className='App'>\n      <SortingTimeVisualizer/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './css/index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './resources/fonts/FiraCode-Regular.ttf';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n","module.exports = __webpack_public_path__ + \"static/media/card-flip.2317ec81.mp3\";","module.exports = __webpack_public_path__ + \"static/media/card-flip-2.c509c85a.mp3\";"],"sourceRoot":""}