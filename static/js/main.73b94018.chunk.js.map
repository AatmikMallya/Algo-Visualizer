{"version":3,"sources":["components/LengthSlider.js","components/SpeedSlider.js","components/Menu.js","components/Info.js","components/InfoBox.js","components/Timer.js","algorithms/Insertion.js","animations/InsertionAnimation.js","algorithms/Merge.js","animations/MergeAnimation.js","algorithms/Quick.js","animations/QuickAnimation.js","algorithms/Selection.js","animations/SelectionAnimation.js","algorithms/Bubble.js","animations/BubbleAnimation.js","algorithms/Heap.js","animations/HeapAnimation.js","algorithms/Counting.js","animations/CountingAnimation.js","algorithms/Shell.js","animations/ShellAnimation.js","components/SortingTimeVisualizer.js","App.js","serviceWorker.js","index.js","resources/card-flip.mp3","resources/card-flip-2.mp3"],"names":["useStyles","makeStyles","root","width","color","input","backgroundColor","borderRadius","slider","LengthSlider","props","classes","React","useState","value","setValue","useEffect","onSlide","className","Typography","id","gutterBottom","Grid","container","spacing","alignItems","item","xs","Slider","min","max","onChange","event","newValue","aria-labelledby","Input","margin","target","Number","onBlur","inputProps","step","type","style","textAlign","disableUnderline","SpeedSlider","Menu","handleSpeedChange","interval","onSpeedChange","handleGenerate","length","onGenerate","handleExecute","onExecute","handleReset","onReset","handleSelect","onSelect","document","getElementById","render","onClick","label","Component","sq","info","selection","header","best","avg","worst","space","body","insertion","merge","quick","bubble","heap","counting","shell","Transition","forwardRef","ref","Slide","direction","InfoBox","styles","position","bottom","button","icon","fontSize","fontWeight","bold","display","normal","paper","algoColors","algorithm","subHeader","marginTop","marginBottom","open","setOpen","handleClose","Button","variant","Dialog","maxWidth","PaperProps","dialog","scroll","TransitionComponent","keepMounted","onClose","aria-describedby","DialogTitle","DialogContent","DialogContentText","ReactHtmlParser","DialogActions","Timer","startTimer","setState","status","timeStart","Date","now","state","time","timer","setInterval","stopTimer","clearInterval","resetTimer","setStatus","bool","setTimeout","centiseconds","Math","floor","slice","seconds","minutes","version","xmlns","viewBox","enableBackground","d","getInsertionAnimations","arr","animations","i","j","temp","push","animateInsertionSort","stateArray","a","getElementsByClassName","colors","purple","wait","animationInterval","isRunning","idx1","idx2","yellow","red","height","cardFlip","play","idx","green","gradients","3","1","2","4","8","5","16","6","32","7","64","getMergeAnimations","b","level","ceil","log2","mergeAnimate","left","right","end","k","animateMergeSort","getQuickAnimations","index","pivotIdx","pivot","partitionAnimate","animateQuickSort","sort","value1","parseInt","value2","getSelectionAnimations","minIdx","animateSelectionSort","undefined","getBubbleAnimations","animateBubbleSort","getHeapAnimations","len","heapifyAnimate","largest","animateHeapSort","playCount","isGreen","cardFlip2","getCountingAnimations","count","hue","mapToHue","animateCountingSort","getShellAnimations","gap","animateShellSort","oldColor","UIfx","cardFlipMp3","throttleMs","volume","cardFlip2Mp3","blue","SortingTimeVisualizer","componentDidMount","maxHeight","getBoundingClientRect","selectAlgorithm","setRunning","timerElement","current","classList","add","remove","speedChange","generateArray","arraySize","array","defaultLength","windowWidth","window","innerWidth","radius","newArray","random","newBars","map","key","bars","cachedArray","resetArray","oldArray","testSort","mySort","startTime","testArr","testArr2","console","log","arrayEquality","elapsedTime","oldHue","getMenuHue","newColor","fade","createRef","ms","Promise","res","menuColors","lerp","u","start","step_u","menu","querySelector","infoButton","setProperty","currentColor","match","r","g","App","ReactGA","initialize","pageview","location","pathname","Boolean","hostname","ReactDOM","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","module","exports"],"mappings":"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","file":"static/js/main.73b94018.chunk.js","sourcesContent":["import React, { useEffect } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport Slider from '@material-ui/core/Slider';\nimport Input from '@material-ui/core/Input';\nimport './Menu.css';\n\nconst useStyles = makeStyles({\n  root: {\n    width: 250,\n    color: 'rgba(100%, 100%, 100%, 82.5%)',\n  },\n  input: {\n    width: 50,\n    color: 'rgba(100%, 100%, 100%, 82.5%)',\n    backgroundColor: 'rgba(100%, 100%, 100%, 20%)',\n    borderRadius: '10px',\n  },\n  slider: {\n    color: 'rgba(100%, 100%, 100%, 82.5%)'\n  }\n});\n\nexport default function LengthSlider(props) {\n  const classes = useStyles();\n  const [value, setValue] = React.useState(25);\n\n  useEffect(() => {\n    if (value < 5) {\n      props.onSlide(5);\n    } else if (value > 125) {\n      props.onSlide(125);\n    } else {\n      props.onSlide(value);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value]);\n\n  const handleSliderChange = (event, newValue) => {\n    setValue(newValue);\n  };\n\n  const handleInputChange = (event) => {\n    setValue(event.target.value === '' ? '' : Number(event.target.value));\n  };\n\n  const handleBlur = () => {\n    if (value < 5) {\n      setValue(5);\n    } else if (value > 125) {\n      setValue(125);\n    }\n  };\n\n  return (\n    <div className={classes.root}>\n      <Typography className='slider-label' id='input-slider' gutterBottom >\n        Array Length\n      </Typography >\n      <Grid container spacing={2} alignItems='center'>\n        <Grid item xs>\n          <Slider\n            className={classes.slider}\n            min={5}\n            max={125}\n            value={typeof value === 'number' ? value : 0}\n            onChange={handleSliderChange}\n            aria-labelledby='input-slider'\n          />\n        </Grid>\n        <Grid item>\n          <Input\n            className={classes.input}\n            value={value}\n            margin='dense'\n            onChange={handleInputChange}\n            onBlur={handleBlur}\n            inputProps={{\n              step: 10,\n              min: 5,\n              max: 125,\n              type: 'number',\n              'aria-labelledby': 'input-slider',\n              style: {textAlign: 'center', color: 'white'},\n            }}\n            disableUnderline\n          />\n        </Grid>\n      </Grid>\n    </div>\n  );\n}\n","import React, { useEffect } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport Slider from '@material-ui/core/Slider';\n\nconst useStyles = makeStyles({\n  root: {\n    width: 220,\n    color: 'rgba(100%, 100%, 100%, 82.5%)'\n  },\n  slider: {\n    color: 'rgba(100%, 100%, 100%, 82.5%)'\n  }\n});\n\n// Sets the time interval between animation frames\nexport default function SpeedSlider(props) {\n  const classes = useStyles();\n  const [value, setValue] = React.useState(10);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => props.onSlide(value), [value]);\n\n  const handleChange = (event, newValue) => setValue(newValue);\n\n  return (\n    <div className={classes.root}>\n      <Typography className='slider-label' id='continuous-slider' gutterBottom>\n        Sorting Speed\n      </Typography>\n      <Grid container spacing={2}>\n        <Grid item>\n        </Grid>\n        <Grid item xs>\n          <Slider value={value} onChange={handleChange} className={classes.slider} aria-labelledby='continuous-slider' />\n        </Grid>\n        <Grid item>\n        </Grid>\n      </Grid>\n    </div>\n  );\n}","import React from 'react';\nimport LengthSlider from './LengthSlider';\nimport SpeedSlider from './SpeedSlider';\nimport './Menu.css';\n\nexport default class Menu extends React.Component {\n    // Event handlers for menu items\n    handleSpeedChange = interval => this.props.onSpeedChange(interval);\n    handleGenerate = length => this.props.onGenerate(length);\n    handleExecute = () => this.props.onExecute();\n    handleReset = () => this.props.onReset();\n\n    handleSelect = () => this.props.onSelect(document.getElementById('menu-select').value);\n\n    render = () => {\n        return (\n            <div id='menu-container'>\n                <div className='menu-item' id='generate' onClick={() => this.handleGenerate()}>New Array</div>\n                <div className='menu-item' id='reset' onClick={() => this.handleReset()}>Reset Array</div>\n                <SpeedSlider onSlide={interval => this.handleSpeedChange(interval)} />\n                <LengthSlider onSlide={length => this.handleGenerate(length)} />\n                <select className='menu-item' id='menu-select' onChange={() => this.handleSelect()}>\n                    <optgroup className='group' label='Simple Sorts'>\n                        <option value='selection'>Selection sort</option>\n                        <option value='insertion'>Insertion sort</option>\n                    </optgroup>\n                    <optgroup className='group' label='Efficient Sorts'>\n                        <option value='merge'>Merge sort</option>\n                        <option value='heap'>Heapsort</option>\n                        <option value='quick'>Quicksort</option>\n                        <option value='shell'>Shell sort</option>\n                    </optgroup>\n                    <optgroup className='group' label='Distribution Sorts'>\n                        <option value='counting'>Counting sort</option>\n                    </optgroup>\n                    <optgroup className='group' label='Other Sorts'>\n                        <option value='bubble'>Bubble sort</option>\n                    </optgroup>\n                    \n                    {/* <option value='comb'>Comb sort</option> */}\n                    {/* <option value='bucket'>Bucket sort</option> */}\n                    {/* <option value='radix'>Radix sort</option> */}\n                    {/* <option value='thanos'>Thanos sort</option> */}\n                </select>\n                <div className='menu-item' id='execute' onClick={() => this.handleExecute()}>Execute</div>\n            </div>\n        );\n    }\n}\n","// Contains all text displayed in the info box\n// const sq = `${'2'.sup()}`;\nconst sq = `<sup style='vertical-align: top; font-size: 0.6em;'>2</sup>`;\nconst info = {\n    selection: {\n        header: `Selection Sort`,\n        best: `n${sq}`,\n        avg: `n${sq}`,\n        worst: `n${sq}`,\n        space: `1`,\n        body: ``    \n    },\n    insertion: {\n        header: `Insertion Sort`,\n        best: `n`,\n        avg: `n${sq}`,\n        worst: `n${sq}`,\n        space: `1`,\n        body: ``\n    },\n    merge: {\n        header: `Merge Sort`,\n        best: `n log(n)`,\n        avg: `n log(n)`,\n        worst: `n log(n)`,\n        space: `n`,\n        body: ``\n    },\n    quick: {\n        header: `Quicksort`,\n        best: `n log(n)`,\n        avg: `n log(n)`,\n        worst: `n${sq}`,\n        space: `log(n)`,\n        body: ``\n    },\n    bubble: {\n        header: `Bubble Sort`,\n        best: `n`,\n        avg: `n${sq}`,\n        worst: `n${sq}`,\n        space: `1`,\n        body: ``\n    },\n    heap: {\n        header: `Heapsort`,\n        best: `n log(n)`,\n        avg: `n log(n)`,\n        worst: `n log(n)`,\n        space: `1`,\n        body: ``\n    },\n    counting: {\n        header: `Counting Sort`,\n        best: `n+k`,\n        avg: `n+k`,\n        worst: `n+k`,\n        space: `k`,\n        body: ``\n    },\n    shell: {\n        header: `Shell Sort`,\n        best: `n log(n)`,\n        avg: `n log(n)${sq}`,\n        worst: `n log(n)${sq}`,\n        space: `1`,\n        body: ``\n    }\n};\nexport default info;\n","import React from 'react';\nimport Button from '@material-ui/core/Button';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport Slide from '@material-ui/core/Slide';\nimport MenuBookIcon from '@material-ui/icons/MenuBook';\nimport info from './Info';\nimport { algoColors } from './SortingTimeVisualizer';\nimport ReactHtmlParser from 'react-html-parser';\nimport './SortingTimeVisualizer.css';\n\n\nconst Transition = React.forwardRef(function Transition(props, ref) {\n  return <Slide direction='left' ref={ref} {...props} />;\n});\n\nexport default function InfoBox(props) {\n  const styles = {\n    container: {\n      position: 'relative',\n      bottom: '5%',\n    },\n    button: {\n      margin: 'auto',\n      borderRadius: '10%',\n    },\n    icon: {\n      fontSize: 75,\n      color: 'black',\n      position: 'relative',\n      bottom: '2px'\n    },\n    header: {\n      color: 'black',\n      fontSize: 35,\n      fontWeight: 800,\n    },\n    bold: {\n      fontWeight: 600,\n      display: 'block',\n    },\n    normal: {\n      fontWeight: 500\n    },\n    paper: {\n      color: 'black',\n      backgroundColor: `hsla(${algoColors[props.algorithm]}, 25%, 70%, 0.94)`\n    },\n    subHeader: {\n      textAlign: 'center',\n      display: 'block',\n      // lineHeight: 3\n      marginTop: 10,\n      marginBottom: 5\n    }\n  };\n\n  const [open, setOpen] = React.useState(false);\n  \n  const handleClickOpen = () => setOpen(true);\n  const handleClose = () => setOpen(false);\n\n  return (\n    <div id='info-box-container' style={styles.container}>\n        <Button id='info-button' variant='outlined' color='primary' onClick={handleClickOpen} style={styles.button}>\n            <MenuBookIcon className='info-icon' style={styles.icon}/>\n        </Button>\n        <Dialog\n          maxWidth='md'\n          PaperProps={{style: styles.paper}}\n          style={styles.dialog}\n          scroll='paper'\n          open={open}\n          TransitionComponent={Transition}\n          keepMounted\n          onClose={handleClose}\n          aria-labelledby='alert-dialog-slide-title'\n          aria-describedby='alert-dialog-slide-description'\n        >\n          <DialogTitle id='alert-dialog-slide-title'>\n            <span id='info-header' style={styles.header}>\n              {info[props.algorithm].header}\n            </span>\n          </DialogTitle>\n          <DialogContent>\n            <DialogContentText id='alert-dialog-slide-description'>\n              <span id='info-header' style={styles.paper}>\n                <span style={styles.subHeader}>Time Complexity</span>\n                <span style={styles.bold}>Best case:\n                  <span style={styles.normal}> &Omega;({ReactHtmlParser(info[props.algorithm].best)})</span>\n                </span>\n                <span style={styles.bold}>Average case:\n                  <span style={styles.normal}> &Theta;({ReactHtmlParser(info[props.algorithm].avg)})</span>\n                </span>\n                <span style={styles.bold}>Worst case:\n                  <span style={styles.normal}> O({ReactHtmlParser(info[props.algorithm].worst)})</span>\n                </span>\n                <span style={styles.bold}>Space complexity:\n                  <span style={styles.normal}> O({ReactHtmlParser(info[props.algorithm].space)})</span>\n                </span>\n              </span>\n            </DialogContentText>\n          </DialogContent>\n          <DialogActions>\n            <Button onClick={handleClose} color='primary'>\n              X\n            </Button>\n          </DialogActions>\n        </Dialog>\n    </div>\n  );\n}\n","import React from 'react';\nimport './Timer.css';\n// https://github.com/peterdurham/timers-demo\n\nexport default class Timer extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            status: this.props.status,\n            timeStart: 0,\n            time: 0\n        };\n    }\n\n    // Starts whenever 'Execute' button is pressed\n    startTimer = () => {\n        this.setState({\n            status: true,\n            timeStart: Date.now() - this.state.time,\n            time: this.state.time\n        });\n        this.timer = setInterval(() => {\n            this.setState({ time: Date.now() - this.state.timeStart });\n        }, 10);\n    }\n\n    stopTimer = () => {\n        this.setState({ status: false });\n        clearInterval(this.timer);\n    }\n\n    resetTimer = () => {\n        this.setState({\n            timeStart: 0,\n            time: 0\n        });\n    }\n\n    setStatus = bool => {\n        if (bool) {\n            if (this.state.status) return;\n            this.resetTimer();\n            // Timer won't reset if this isn't in a setTimeout\n            setTimeout(() => this.startTimer(), 0);\n        }\n        else {\n            this.stopTimer();\n        }\n    }\n    \n    render = () => {\n        const { time } = this.state;\n        const centiseconds = ('0' + (Math.floor(time / 10) % 100)).slice(-2);\n        const seconds = ('0' + (Math.floor(time / 1000) % 60)).slice(-2);\n        const minutes = ('0' + (Math.floor(time / 60000) % 60)).slice(-2);\n        return (\n            <span id='timer-container' className='noselect'>\n                <span className='timer timer-icon'>\n                    <svg version='1.1' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 296.228 296.228' enableBackground='new 0 0 296.228 296.228'>\n                        <g>\n                            <path d='m167.364,48.003v-23.003h10.5c6.903,0 12.5-5.597 12.5-12.5s-5.596-12.5-12.5-12.5h-59.5c-6.903,0-12.5,5.597-12.5,12.5s5.597,12.5 12.5,12.5h10.5v23.003c-59.738,9.285-105.604,61.071-105.604,123.37-3.55271e-15,68.845 56.01,124.854 124.854,124.854s124.854-56.01 124.854-124.854c0-62.299-45.866-114.085-105.604-123.37zm-19.25,223.225c-55.06,0-99.854-44.795-99.854-99.854s44.795-99.854 99.854-99.854 99.854,44.795 99.854,99.854-44.794,99.854-99.854,99.854z'/>\n                            <path d='m160.614,166.18v-58.889c0-6.903-5.597-12.5-12.5-12.5s-12.5,5.597-12.5,12.5v66.1c0,2.033 0.81,3.982 2.25,5.416l34.969,34.822c4.893,4.872 12.806,4.854 17.678-0.037 4.871-4.892 4.854-12.807-0.037-17.678l-29.86-29.734z'/>\n                        </g>\n                    </svg>\n                </span>\n                <span className='timer timer-display'>\n                    <span id='seconds'>{minutes}:{seconds}</span>\n                    <span id='centiseconds'>{centiseconds}</span>\n                </span>\n            </span>\n      );\n    }\n  }\n","const purple = '#8a2be2';\n\n// Executes sorting algorithm and determines the sequence of animations\nexport default function getInsertionAnimations(arr) {\n    const animations = [];\n\n    for (let i = 1; i < arr.length; i++) {\n        let j = i - 1;\n        const temp = arr[i];\n        // arr[i] = purple\n        animations.push([i, purple])\n        while (j >= 0 && arr[j] > temp) {\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            // Swap arr[j], arr[j + 1]\n            animations.push([j, j + 1])\n            j--;\n        }\n    }\n\n    return animations;\n}\n\n\n\n// Original insertion algo w/ more swapping for better visual\n// export function insertionAlgo(arr) {\n//     for (let i = 1; i < arr.length; i++) {\n//         let j = i - 1;\n//         const temp = arr[i];\n//         while (j >= 0 && arr[j] > temp) {\n//             [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n//             j--;\n//         }\n//     }\n//     return arr;\n// }\n\n// More efficient version - less swapping\n// export function insertionAlgo2(arr) {\n//     for (let i = 1; i < arr.length; i++) {\n//         let j = i - 1;\n//         const temp = arr[i];\n//         while (j >= 0 && arr[j] > temp) {\n//             arr[j+1] = arr[j];\n//             j--;\n//         }\n//         arr[j+1] = temp;\n//     }\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getInsertionAnimations from '../algorithms/Insertion';\n\n// Render insertion sort animations\nexport default async function animateInsertionSort(stateArray) {\n    const animations = getInsertionAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    // First bar will be purple (current min)\n    arr[0].style.backgroundColor = colors.purple;\n    await wait(animationInterval);\n    \n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // Swap two elements\n        if (typeof animations[i][1] === 'number') {\n            const [idx1, idx2] = animations[i];\n            \n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.red;\n            await wait(animationInterval);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            arr[idx1].style.backgroundColor = colors.red;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            arr[idx2].style.backgroundColor = colors.purple;\n            if (i === animations.length - 1 || typeof animations[i + 1][1] !== 'number') {\n                cardFlip.play();\n                await wait(animationInterval);\n                arr[idx1].style.backgroundColor = colors.purple;\n            }\n        }\n        // Color an element\n        else {\n            const [idx, color] = animations[i];\n            arr[idx].style.backgroundColor = color;\n            await wait(animationInterval);\n        }\n    }\n\n    await wait(500);\n    for (let i = 0; i < arr.length / 2; i++) {\n        arr[i].style.backgroundColor = colors.green;\n        arr[arr.length - i - 1].style.backgroundColor = colors.green;\n        await wait(1000 / arr.length);\n    }\n}\n","const purple = '#8a2be2';\n// Based on array size\nconst gradients = {\n  3: { 1: '#00747f', 2: '#0073e7', 4: purple },\n  4: { 1: '#007264', 2: '#0076b8', 4: '#006cf5', 8: purple },\n  5: { 1: '#007056', 2: '#007596', 4: '#0075d7', 8: '#0066f9', 16: purple },\n  6: { 1: '#006f4d', 2: '#00747f', 4: '#0076b8', 8: '#0073e7', 16: '#0061fa', 32: purple },\n  7: { 1: '#006e47', 2: '#00736f', 4: '#0076a0', 8: '#0076cf', 16: '#0070f0', 32: '#005df9', 64: purple }\n};\n\n// Executes sorting algorithm and determines the sequence of animations\nexport default function getMergeAnimations(a) {\n  const animations = [], b = [];\n  const level = Math.ceil(Math.log2(a.length))\n\n  for (let width = 1; width < a.length; width *= 2) {\n    const color = gradients[level][width];\n    // Play card flip sound effect\n    animations.push(null);\n    \n    for (let i = 0; i < a.length; i += 2 * width) {\n      mergeAnimate(a, i, Math.min(i + width, a.length), Math.min(i + 2*width, a.length), b, animations, color);\n    }\n    for (let i = 0; i < a.length; i++) {\n      a[i] = b[i];\n    }\n  }\n  return animations\n}\n\nfunction mergeAnimate(a, left, right, end, b, animations, color) {\n  let i = left, j = right;\n  for (let k = left; k < end; k++) {\n    if (i < right && (j >= end || a[i] <= a[j])) {\n      // arr[i] = color\n      animations.push([color, i]);\n      b[k] = a[i++];\n    }\n    else {\n      // Swap two elements\n      animations.push([color, k, j]);\n      b[k] = a[j++];\n    }\n  }\n}\n\n\n// Original merge sort algorithm\n// export function mergeAlgo(a) {\n//   const b = [];\n\n//   for (let width = 1; width < a.length; width *= 2) {\n//     for (let i = 0; i < a.length; i += 2 * width) {\n//       merge(a, i, Math.min(i + width, a.length), Math.min(i + 2*width, a.length), b);\n//     }\n//     for (let i = 0; i < a.length; i++) {\n//       a[i] = b[i];\n//     }\n//   }\n\n//   return a\n// }\n\n// function merge(a, left, right, end, b) {\n//   let i = left, j = right;\n  \n//   for (let k = left; k < end; k++) {\n//     if (i < right && (j >= end || a[i] <= a[j])) {\n//       b[k] = a[i++];\n//     }\n//     else {\n//       b[k] = a[j++];\n//     }\n//   }\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getMergeAnimations from '../algorithms/Merge';\n\n// Render merge sort animations\nexport default async function animateMergeSort(stateArray) {\n    const animations = getMergeAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // New merge iteration\n        if (!animations[i]) {\n            cardFlip.play();\n        }\n        // Swap two elements\n        else if (animations[i].length === 3) {\n            const [color, idx1, idx2] = animations[i];\n\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            const temp = arr[idx2].style.height;\n            for (let i = idx2; i > idx1; i--) {\n                arr[i].style.height = arr[i - 1].style.height;\n            }\n            arr[idx1].style.height = temp;\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = color;\n            await wait(animationInterval);\n\n            arr[idx1].style.backgroundColor = color;\n            await wait(animationInterval);\n        }\n        // Color one element\n        else {\n            const [color, idx] = animations[i];\n            arr[idx].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            arr[idx].style.backgroundColor = color;\n            await wait(animationInterval);\n        }\n    }\n\n    await wait(500);\n    for (let i = 0; i < arr.length / 2; i++) {\n        arr[i].style.backgroundColor = colors.green;\n        arr[arr.length - i - 1].style.backgroundColor = colors.green;\n        await wait(1000 / arr.length);\n    }\n}\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getQuickAnimations(arr, left, right, animations) {\n    let index;\n    if (arr.length > 1) {\n        index = partitionAnimate(arr, left, right, animations);\n        if (left < index - 1) {\n            getQuickAnimations(arr, left, index - 1, animations);\n        }\n        if (index < right) {\n            getQuickAnimations(arr, index, right, animations);\n        }\n    }\n    return animations;\n}\n\nfunction partitionAnimate(arr, left, right, animations) {\n    const pivotIdx = Math.floor((right + left) / 2)\n    const pivot = arr[pivotIdx];\n    // Color the pivot element red\n    animations.push([pivotIdx])\n    \n    let i = left;\n    let j = right;\n\n    while (i <= j) {\n        while (arr[i] < pivot) {\n            i++;\n        }\n        while (arr[j] > pivot) {\n            j--;\n        }\n        if (i <= j) {\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n            // Swap arr[i], arr[j]\n            animations.push([i, j])\n            i++;\n            j--;\n        }\n    }\n    return i;\n}\n\n\n// Original quicksort algorithm\n// export function quickAlgo(arr, left, right) {\n//     let index;\n//     if (arr.length > 1) {\n//         index = partition(arr, left, right);\n//         if (left < index - 1) { // more elements on the left side of the pivot\n//             quickAlgo(arr, left, index - 1);\n//         }\n//         if (index < right) { // more elements on the right side of the pivot\n//             quickAlgo(arr, index, right);\n//         }\n//     }\n//     return arr;\n// }\n\n// function partition(arr, left, right) {\n//     const pivot = arr[Math.floor((right + left) / 2)];\n    \n//     let i = left;\n//     let j = right;\n\n//     while (i <= j) {\n//         while (arr[i] < pivot) {\n//             i++;\n//         }\n//         while (arr[j] > pivot) {\n//             j--;\n//         }\n//         if (i <= j) {\n//             [arr[i], arr[j]] = [arr[j], arr[i]];\n//             i++;\n//             j--;\n//         }\n//     }\n//     return i;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getQuickAnimations from '../algorithms/Quick';\n\n// Render quick sort animations\nexport default async function animateQuickSort(stateArray) {\n    const animations = getQuickAnimations(stateArray, 0, stateArray.length - 1, []);\n    const arr = document.getElementsByClassName('array');\n    stateArray.sort((a, b) => a - b);\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) return;\n        // Select new pivot\n        if (animations[i].length === 1) {\n            cardFlip.play();\n            const [idx] = animations[i];\n\n            arr[idx].style.backgroundColor = colors.red;\n            await wait(animationInterval + 10);\n        }\n        // Swap two elements\n        else {\n            const [idx1, idx2] = animations[i];\n\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval + 10);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            await wait(animationInterval + 10);\n\n            const value1 = parseInt(arr[idx1].style.height.slice(0, -2));\n            const value2 = parseInt(arr[idx2].style.height.slice(0, -2));\n            arr[idx1].style.backgroundColor = value1 === stateArray[idx1] ? colors.purple : colors.green;\n            arr[idx2].style.backgroundColor = value2 === stateArray[idx2] ? colors.purple : colors.green;\n            await wait(animationInterval + 10);\n        }\n    }\n    \n    await wait(500);\n    for (let i = 0; i < arr.length / 2; i++) {\n        arr[i].style.backgroundColor = colors.green;\n        arr[arr.length - i - 1].style.backgroundColor = colors.green;\n        await wait(1000 / arr.length);\n    }\n}\n","const purple = '#8a2be2';\nconst red = '#dc143c';\n\n// Executes sorting algorithm and determines the sequence of animations\nexport default function getSelectionAnimations(arr) {\n    const animations = [];\n    \n    for (let i = 0; i < arr.length; i++) {\n        let minIdx = i;\n        // arr[i] = purple\n        animations.push([i, purple, 'sorted'])\n        for (let j = i + 1; j < arr.length; j++) {\n            if (arr[j] < arr[minIdx]) {\n                minIdx = j;\n                // arr[j] = purple\n                animations.push([j, purple])\n            }\n            else {\n                // arr[j] = red\n                animations.push([j, red])\n            }\n        }\n\n        if (minIdx > i) {\n            [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n            // Swap a[i], a[minIdx]\n            animations.push([i, minIdx]);\n        }\n    }\n\n    return animations;\n}\n\n\n// Original selection sort algorithm\n// export function selectionAlgo(arr) {\n//     let minIdx;\n    \n//     for (let i = 0; i < arr.length; i++) {\n//         minIdx = i;\n//         for (let j = i + 1; j < arr.length; j++) {\n//             if (arr[j] < arr[minIdx]) {\n//                 minIdx = j;\n//             }\n//         }\n\n//         if (minIdx > i) {\n//             [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n//         }\n//     }\n\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getSelectionAnimations from '../algorithms/Selection';\n\n// Render selection sort animations\nexport default async function animateSelectionSort(stateArray) {\n    const animations = getSelectionAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n    \n    // First bar will be purple (current min)\n    arr[0].style.backgroundColor = colors.purple;\n    await wait(animationInterval);\n    \n    for (let i = 1; i < animations.length; i++) {\n        if (!isRunning) return;\n        // Swap two elements\n        if (typeof animations[i][1] === 'number') {\n            cardFlip.play();\n            // Last element is still red\n            arr[animations[i - 1][0]].style.backgroundColor = colors.green;\n            const [idx1, idx2] = animations[i];\n\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            await wait(animationInterval);\n\n            arr[idx1].style.backgroundColor = colors.purple;\n            arr[idx2].style.backgroundColor = colors.green;\n            await wait(animationInterval);\n        }\n        // Color a bar red/purple to indicate result of comparison\n        else {\n            const [idx, color, type] = animations[i];\n            arr[idx].style.backgroundColor = color;\n            arr[idx].type = type;\n\n            if (animations[i - 1][1] === colors.red) {\n                arr[animations[i - 1][0]].style.backgroundColor = colors.green;\n            }\n            // Reset the previous min to green\n            if (color === colors.purple) {\n                for (let j = idx - 1; j > 0; j--) {\n                    if (arr[j].type !== 'sorted' && arr[j].style.backgroundColor === 'rgb(138, 43, 226)') { //purple\n                        arr[j].style.backgroundColor = colors.green;\n                    }\n                }\n            }\n            await wait(animationInterval);\n        }\n    }\n    \n    arr[arr.length - 1].style.backgroundColor = colors.purple;\n    await wait(animationInterval);\n\n    await wait(500);\n    for (let i = 0; i < arr.length / 2; i++) {\n        arr[i].style.backgroundColor = colors.green;\n        arr[i].type = undefined;\n        arr[arr.length - i - 1].style.backgroundColor = colors.green;\n        arr[arr.length - i - 1].type = undefined;\n        await wait(1000 / arr.length);\n    }\n}\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getBubbleAnimations(arr) {\n    const animations = [];\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                // Swap arr[j], arr[j + 1]\n                animations.push([j, j + 1]);\n            }\n        }\n    }\n    return animations;\n}\n\n\n// Original bubble sort algorithm\n// export function bubbleAlgo(arr) {\n//     for (let i = 0; i < arr.length; i++) {\n//         for (let j = 0; j < arr.length; j++) {\n//             if (arr[j] > arr[j + 1]) {\n//                 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n//             }\n//         }\n//     }\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getBubbleAnimations from '../algorithms/Bubble';\n\n// Render bubble sort animations\nexport default async function animateBubbleSort(stateArray) {\n    const animations = getBubbleAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) break;\n        // Only operation is swapping\n        const [idx1, idx2] = animations[i];\n        arr[idx1].style.backgroundColor = colors.yellow;\n        arr[idx2].style.backgroundColor = colors.yellow;\n        await wait(animationInterval);\n\n        [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n        await wait(animationInterval);\n        \n        const value1 = parseInt(arr[idx1].style.height.slice(0, -2));\n        const value2 = parseInt(arr[idx2].style.height.slice(0, -2));\n        arr[idx1].style.backgroundColor = value1 === stateArray[idx1] ? colors.purple : colors.green;\n        if (value2 === stateArray[idx2]) {\n            cardFlip.play();\n            arr[idx2].style.backgroundColor = colors.purple;\n        }\n        else {\n            arr[idx2].style.backgroundColor = colors.green;\n        }\n        \n        await wait(animationInterval);\n    }\n\n    await wait(500);    \n    for (let i = 0; i < arr.length / 2; i++) {\n        arr[i].style.backgroundColor = colors.green;\n        arr[arr.length - i - 1].style.backgroundColor = colors.green;\n        await wait(1000 / arr.length);\n    }\n}\n\n","// Executes sorting algorithm and determines the sequence of animations\nexport default function getHeapAnimations(arr) {\n    const animations = [];\n    const len = arr.length\n    let i  = Math.floor(len / 2 - 1);\n    // Last index of heap\n    let j = len - 1;\n\n    while (i >= 0) {\n        heapifyAnimate(arr, len, i, animations);\n        i--;\n    }\n\n    while (j >= 0) {\n        [arr[0], arr[j]] = [arr[j], arr[0]];\n        // Swap arr[0], arr[j]\n        animations.push([0, j])\n        heapifyAnimate(arr, j, 0, animations);\n        j--;\n    }\n    \n    return animations;\n}\n\nfunction heapifyAnimate(arr, len, i, animations) {\n    let largest = i;\n    const left = i * 2 + 1;\n    const right = left + 1;\n\n    if (left < len && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    if (right < len && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    if (largest !== i) {\n        [arr[i], arr[largest]] = [arr[largest], arr[i]];\n        // Swap arr[i], arr[largest]\n        animations.push([i, largest, true])\n        heapifyAnimate(arr, len, largest, animations);\n    }\n}\n\n\n// // Original heap sort algorithm\n// export function heapAlgo(arr) {\n//     const len = arr.length\n//     let i  = Math.floor(len / 2 - 1);\n//     // Last index of heap\n//     let j = len - 1;\n\n//     while (i >= 0) {\n//         heapify(arr, len, i);\n//         i--;\n//     }\n\n//     while (j >= 0) {\n//         [arr[0], arr[j]] = [arr[j], arr[0]];\n//         heapify(arr, j, 0);\n//         j--;\n//     }\n    \n//     return arr;\n// }\n\n// function heapify(arr, len, i) {\n//     let largest = i;\n//     const left = i * 2 + 1;\n//     const right = left + 1;\n\n//     if (left < len && arr[left] > arr[largest]) {\n//         largest = left;\n//     }\n//     if (right < len && arr[right] > arr[largest]) {\n//         largest = right;\n//     }\n\n//     if (largest !== i) {\n//         [arr[i], arr[largest]] = [arr[largest], arr[i]];\n//         heapify(arr, len, largest);\n//     }\n// }\n","import { cardFlip, cardFlip2, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getHeapAnimations from '../algorithms/Heap';\n\n// Render heap sort animations\nexport default async function animateHeapSort(stateArray) {\n    const animations = getHeapAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    let playCount = 0;\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) break;\n        // Only procedure is swapping\n        const [idx1, idx2, isGreen] = animations[i];\n        arr[idx1].style.backgroundColor = colors.yellow;\n        arr[idx2].style.backgroundColor = colors.yellow;\n        await wait(animationInterval);\n\n        [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n        await wait(animationInterval);\n        \n        arr[idx1].style.backgroundColor = colors.green;\n        if (isGreen) {\n            if (++playCount === 3) {\n                playCount = 0;\n                cardFlip.play();\n            }\n            arr[idx2].style.backgroundColor = colors.green;\n        }\n        else {\n            playCount = 4;\n            cardFlip2.play();\n            arr[idx2].style.backgroundColor = colors.purple;\n        }\n        await wait(animationInterval);\n    }\n\n    await wait(500); \n    for (let i = 0; i < arr.length / 2; i++) {\n        arr[i].style.backgroundColor = colors.green;\n        arr[arr.length - i - 1].style.backgroundColor = colors.green;\n        await wait(1000 / arr.length);\n    }\n}","let min, max;\n\n// Executes sorting algorithm and determines the sequence of animations\nexport default function getCountingAnimations(arr) {\n    const animations = [];\n    max = Math.max(...arr);\n    min = Math.min(...arr);\n    let i = min;\n    let j = 0;\n    let count = [];\n\n    for (i; i <= max; i++) {\n        count[i] = 0;\n    }\n    for (i = 0; i < arr.length; i++) {\n        count[arr[i]]++;\n        const hue = mapToHue(arr[i]);\n        animations.push([i, hue]);\n    }\n\n    for (i = min; i <= max; i++) {\n        while (count[i] > 0) {\n            arr[j] = i;\n            const hue = mapToHue(i);\n            animations.push([j, i, hue]);\n            j++;\n            count[i]--;\n        }\n    }\n    \n    return animations;\n}\n\n\n// Original counting sort algorithm\n// export function countingAlgo(arr) {\n//     max = Math.max(...arr);\n//     min = Math.min(...arr);\n//     let i = min;\n//     let j = 0;\n//     let count = [];\n\n//     for (i; i <= max; i++) {\n//         count[i] = 0;\n//     }\n//     for (i = 0; i < arr.length; i++) {\n//         count[arr[i]]++;\n//     }\n\n//     for (i = min; i <= max; i++) {\n//         while (count[i] > 0) {\n//             arr[j] = i;\n//             j++;\n//             count[i]--;\n//         }\n//     }\n\n//     return arr;\n// }\n\n// Maps a value to the 0-240 range on the hue wheel based on value range\nfunction mapToHue(value) {\n    // a1,a2 --> min,max\n    // b1,b2 --> 0, 240\n    return 240 * (value - min) / (max - min);\n}\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getCountingAnimations from '../algorithms/Counting';\n\n// Render heap sort animations\nexport default async function animateCountingSort(stateArray) {\n    const animations = getCountingAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    \n    // Color array elements according to their value\n    let i = 0;\n    for (i; i < animations.length / 2; i++) {\n        if (!isRunning) break;\n\n        const [idx, hue] = animations[i];\n        arr[idx].style.backgroundColor = `hsl(${hue}, 100%, 45%)`;\n        await wait(animationInterval + 10);\n    }\n    await wait(500);\n\n    // Sorting step\n    for (i; i < animations.length; i++) {\n        if (!isRunning) break;\n        const [idx, height, hue] = animations[i];\n        if (arr[idx].style.height !== height + 'px') {\n            cardFlip.play();\n            arr[idx].style.height = height + 'px';\n        }\n        arr[idx].style.backgroundColor = `hsl(${hue}, 100%, 45%)`;\n\n        await wait(animationInterval + 10);\n    }\n    await wait(500);\n    for (let i = 0; i < arr.length / 2; i++) {\n        arr[i].style.backgroundColor = colors.green;\n        arr[arr.length - i - 1].style.backgroundColor = colors.green;\n        await wait(1000 / arr.length);\n    }\n}","// Executes sorting algorithm and determines the sequence of animations\nexport default function getShellAnimations(arr) {\n    const animations = [];\n\n    const len = arr.length;\n    for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n        // New shell iteration\n        for (let i = gap; i < len; i++) {\n            const temp = arr[i];\n            // arr[i] = purple\n            animations.push([i]);\n            for (let j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                [arr[j], arr[j - gap]] = [arr[j - gap], arr[j]];\n                // Swap arr[j], arr[j - gap]\n                animations.push([j - gap, j]);\n            }\n        }\n    }\n    \n    return animations;\n}\n\n\n// Original shell algo w/ more swapping for better visual\n// export function shellAlgo(arr) {\n//     const len = arr.length;\n//     for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n//         for (let i = gap; i < len; i++) {\n//             const temp = arr[i];\n//             for (let j = i; j >= gap && arr[j-gap] > temp; j -= gap) {\n//                 [arr[j], arr[j-gap]] = [arr[j-gap], arr[j]];\n//             }\n//         }\n//     }\n//     return arr;\n// }\n\n// More efficient version - less swapping\n// export function shellAlgo2(arr) {\n//     const len = arr.length;\n//     let gap = Math.floor(len / 2);\n//     while (gap > 0) {\n//         for (let i = gap; i < len; i++) {\n//             const temp = arr[i];\n//             let j = i;\n//             while (j >= gap && arr[j-gap] > temp) {\n//                 arr[j] = arr[j-gap];\n//                 j -= gap;\n//             }\n//             arr[j] = temp;\n//         }\n//         gap = Math.floor(gap / 2);\n//     }\n//     return arr;\n// }\n","import { cardFlip, wait, colors, isRunning, animationInterval } from '../components/SortingTimeVisualizer';\nimport getShellAnimations from '../algorithms/Shell';\n\n// Render shell sort animations\nexport default async function animateShellSort(stateArray) {\n    const animations = getShellAnimations(stateArray);\n    const arr = document.getElementsByClassName('array');\n\n    for (let i = 0; i < animations.length; i++) {\n        if (!isRunning) break;\n        // Swap two elements\n        if (animations[i].length > 1) {\n            cardFlip.play();\n            const [idx1, idx2] = animations[i];\n            arr[idx1].style.backgroundColor = colors.yellow;\n            arr[idx2].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n\n            [arr[idx1].style.height, arr[idx2].style.height] = [arr[idx2].style.height, arr[idx1].style.height];\n            await wait(animationInterval);\n            \n            const value1 = parseInt(arr[idx1].style.height.slice(0, -2));\n            const value2 = parseInt(arr[idx2].style.height.slice(0, -2));\n            arr[idx1].style.backgroundColor = value1 === stateArray[idx1] ? colors.purple : colors.green;\n            arr[idx2].style.backgroundColor = value2 === stateArray[idx2] ? colors.purple : colors.green;\n            await wait(animationInterval);\n        }\n        // Color an element\n        else {\n            const [idx] = animations[i];\n            const oldColor = arr[idx].style.backgroundColor;\n            arr[idx].style.backgroundColor = colors.yellow;\n            await wait(animationInterval);\n            arr[idx].style.backgroundColor = oldColor;\n            await wait(animationInterval);\n        }\n    }\n\n    await wait(500);    \n    for (let i = 0; i < arr.length / 2; i++) {\n        arr[i].style.backgroundColor = colors.green;\n        arr[arr.length - i - 1].style.backgroundColor = colors.green;\n        await wait(1000 / arr.length);\n    }\n}\n\n","import React from 'react';\nimport Menu from './Menu';\nimport InfoBox from './InfoBox';\nimport Timer from './Timer';\nimport UIfx from 'uifx';\nimport cardFlipMp3 from '../resources/card-flip.mp3';\nimport cardFlip2Mp3 from '../resources/card-flip-2.mp3';\nimport './SortingTimeVisualizer.css';\n\nimport animateInsertionSort from '../animations/InsertionAnimation';\nimport animateMergeSort from '../animations/MergeAnimation';\nimport animateQuickSort from '../animations/QuickAnimation';\nimport animateSelectionSort from '../animations/SelectionAnimation';\nimport animateBubbleSort from '../animations/BubbleAnimation';\nimport animateHeapSort from '../animations/HeapAnimation';\nimport animateCountingSort from '../animations/CountingAnimation';\nimport animateShellSort from '../animations/ShellAnimation';\n\n// import { shellAlgo } from '../algorithms/Shell';\n\n// Not very React-y, but these are only passed to animation/algorithm scripts that execute the sort\nexport let isRunning = false;\nexport let animationInterval = 0;\nexport const cardFlip = new UIfx(cardFlipMp3, { throttleMs: 60, volume: 0.7 });\nexport const cardFlip2= new UIfx(cardFlip2Mp3,{ throttleMs: 120,volume: 0.6 });\nexport const colors = {\n    purple: '#8a2be2',\n    red: '#dc143c',\n    green: '#24682d',\n    yellow: '#ffff00',\n    blue: '#0076b8'\n};\n\n\n//* Main component of application *//\nexport default class SortingTimeVisualizer extends React.Component {\n    constructor(props) {\n        super(props);\n        // array holds height values, bars holds the actual divs\n        this.state = {\n            array: [],\n            bars: [],\n            algorithm: 'selection'\n        };\n        \n        this.cachedArray = [];\n        this.defaultLength = 60;\n        this.maxHeight = 550;\n        this.timerElement = React.createRef();\n    }\n\n    componentDidMount = () => {\n        // 85% of the distance between array container and menu\n        this.maxHeight = Math.floor(0.85 * (document.getElementById('bars-container').getBoundingClientRect().bottom -\n                                            document.getElementById('menu-container').getBoundingClientRect().bottom));\n        // initializeTheme();\n        this.selectAlgorithm('selection')\n    }\n    \n    // True if algorithm is currently running, false otherwise\n    setRunning = async bool => {\n        isRunning = bool;\n        this.timerElement.current.setStatus(bool);\n        if (bool) {\n            document.getElementById('execute').classList.add('running');\n        } else {\n            document.getElementById('execute').classList.remove('running');\n        }            \n    }\n\n    // Compute reciprocal of interval to make the slider feel linear\n    speedChange = interval => {\n        animationInterval = interval < 5 ? 300 : 1500/interval - 15;\n    }\n\n    // Display a new randomized array, possibly with a new length\n    generateArray = length => {\n        const array = document.getElementsByClassName('array');\n        if (isRunning) {\n            this.setRunning(false);\n        }\n        let arraySize;\n        if (length) {\n            arraySize = length;\n            this.defaultLength = length;\n        } else {\n            arraySize = this.defaultLength;\n        }\n\n        // The constant values are arbitrary and were chosen because they look nice\n        const windowWidth = window.innerWidth;\n        const margin = Math.max((windowWidth) / (10 * arraySize), 1.5);\n        const width = Math.max((windowWidth - 100) / (1.75 * arraySize), 7);\n        const radius = Math.max(width / 10, 3);\n        \n        const newArray = [];\n        for (let i = 0; i < arraySize; i++) {\n            newArray.push(Math.floor(Math.random() * this.maxHeight + 25));\n        }\n        //const newArray = [ 15, 200, 150, 25, 300 ];\n        const newBars = newArray.map((value, i) => <div className='array' key={i} idx={i} color={colors.green} type={undefined} style={{\n            height: value,\n            margin: margin,\n            width: width,\n            borderRadius: radius,\n        }} />);\n        this.setState({\n            array: newArray,\n            bars: newBars\n        });\n\n        // Deep copy to allow resetting to original state\n        this.cachedArray = [];\n        for (let i = 0; i < newArray.length; i++) {\n            this.cachedArray.push(newArray[i]);\n        }\n\n        // In case we are currently in execution\n        for (let i = 0; i < array.length; i++) {\n            array[i].style.backgroundColor = colors.green;\n        }\n    }\n\n    // Return bar heights and colors to pre-sorted state\n    resetArray = async () => {\n        cardFlip.play()\n        const array = document.getElementsByClassName('array');\n        const arraySize = array.length;\n\n        this.setRunning(false);\n\n        const oldArray = []\n        for (let i = 0; i < arraySize; i++) {\n            array[i].style.height = this.cachedArray[i] + 'px';\n            array[i].type = undefined;\n            oldArray.push(this.cachedArray[i]);\n        }\n\n        this.setState({array: oldArray});\n        \n        for (let i = 0; i < arraySize; i++) {\n            array[i].style.backgroundColor = '#07ad1d';\n        }\n        await wait(333);\n        for (let i = 0; i < arraySize; i++) {\n            array[i].style.backgroundColor = colors.green;\n        }\n    }\n\n    // Generates many large arrays, logs 'true' for each correct sort\n    testSort = mySort => {\n        const startTime = new Date();\n        for (let i = 0; i < 100; i++) {\n            const testArr = [];\n            const length = Math.floor(Math.random()*1001);\n            for (let j = 0; j < length; j++) {\n                testArr.push(Math.floor(Math.random()*501));\n            }\n            const testArr2 = [...testArr];\n    \n            mySort(testArr, 0, testArr.length - 1);\n            // correctSort(testArr2);\n            testArr2.sort((a, b) => a - b);\n    \n            console.log(arrayEquality(testArr, testArr2));\n        }\n        const elapsedTime = new Date() - startTime;\n        console.log('Elapsed time: ', elapsedTime, ' ms');\n    }\n\n    // Response to selecting algorithm from dropdown\n    selectAlgorithm = async selection => {\n        this.setState({ algorithm: selection });\n        const oldHue = getMenuHue();\n        const newColor = algoColors[selection];\n        await fade(oldHue, newColor);\n    }\n\n    // Runs selected algorithm\n    handleExecute = async () => {\n        if (isRunning) return;\n        cardFlip.play(0);\n        this.setRunning(true);\n\n        const array = this.state.array;\n        switch (this.state.algorithm) {\n            case 'shell': await animateSelectionSort(array); break;\n            case 'insertion': await animateInsertionSort(array); break;\n            case 'merge': await animateMergeSort(array); break;\n            case 'quick': await animateQuickSort(array); break;\n            case 'bubble': await animateBubbleSort(array); break;\n            case 'heap': await animateHeapSort(array); break;\n            case 'counting': await animateCountingSort(array); break;\n            case 'selection': await animateShellSort(array); break;\n            default: await animateSelectionSort(array);\n        }\n\n        this.setRunning(false);\n    }\n\n    // Everything on screen is rendered here\n    render = () => {\n        return (\n            <div>\n                <div id='color-strip' />\n                <Menu onGenerate={this.generateArray} onReset={this.resetArray} onSpeedChange={this.speedChange} onExecute={this.handleExecute} onSelect={this.selectAlgorithm} />\n                <div id='body-container'>\n                    <div id='left-container'>\n                        {/* TODO: ALIGNMENT BUTTONS */}\n                    </div>\n                    <div id='bars-container'>\n                        {this.state.bars}\n                        {/* Used for testing algorithms */}\n                        {/* <button id='test-sort' onClick={this.testSort.bind(this, shellAlgo)}>Test Sort</button> */}\n                    </div>\n                    <div id='right-container'>\n                        <InfoBox algorithm={this.state.algorithm} />\n                    </div>\n                </div>\n                \n                <Timer status={isRunning} ref={this.timerElement}/>\n            </div>\n        )\n    }\n}\n\n\n//* Helpers *//\n// Effectively a synchronous sleep function\nexport const wait = ms => new Promise(res => setTimeout(res, ms));\n\n// For testing purposes\nconst arrayEquality = (a, b) => {\n\tif (a.length !== b.length) {\n        return false;\n    }\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// For menu color fading - based on average case\nexport const menuColors = {\n    purple: 270, // Initial\n    red: 5,      // O(n^2)\n    orange: 28,  // O(nlogn)\n    yellow: 45,  // O(n)\n    // Specific algorithms\n    shell: 18,   // O(n(logn)^2)\n};\n\nexport const algoColors = {\n    selection: menuColors.red,\n    insertion: menuColors.red,\n    merge: menuColors.orange,\n    quick: menuColors.orange,\n    bubble: menuColors.red,\n    heap: menuColors.orange,\n    counting: menuColors.yellow,\n    shell: menuColors.shell\n};\n\n// Linear interpolation\nconst lerp = (a,b,u) => (1-u) * a + u * b;\n\n// Transition color theme\nconst fade = async (start, end) => {\n    const duration = 1000;\n    const interval = 10;\n    const step_u = interval / duration;\n    const menu = document.getElementById('menu-container').style;\n    const icon = document.querySelector('.info-icon').style;\n    const infoButton = document.getElementById('info-button').style;\n    for (let u = 0.0; u < 1.0; u += step_u) {\n        const hue = parseInt(lerp(start, end, u));\n        menu.setProperty('background-color', `hsl(${hue}, 95%, 35%)`);\n        menu.setProperty('box-shadow', `-1.5px 1.5px 2.5px hsl(${hue}, 95%, 15%)`);\n        icon.setProperty('color',`hsl(${hue}, 95%, 20%)`)\n        infoButton.setProperty('border-color', `hsl(${hue}, 95%, 25%)`);\n        infoButton.setProperty('background-color', `hsla(${hue}, 95%, 30%, 0.1)`);\n        await wait(interval);\n    }\n};\n\nconst getMenuHue = () => {\n    const menu = document.getElementById('menu-container');\n    const currentColor = menu.style.backgroundColor.match(/\\d+/g)?.map(Number);\n    if (!currentColor) return menuColors.purple;\n    const [r, g, b] = [currentColor[0]/255, currentColor[1]/255, currentColor[2]/255];\n    const max = Math.max(r, g, b), min = Math.min(r, g, b);\n    let hue = 0;\n    if (max !== min) {\n        const d = max - min;\n        switch (max) {\n            case r: hue = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: hue = (b - r) / d + 2; break;\n            case b: hue = (r - g) / d + 4; break;\n            default: break;\n        }\n    }\n    return hue * 60;\n};\n\n// RGB Version\n// const fade = async (element, property, start, end, duration) => {\n//   const interval = 10;\n//   const step_u = interval / duration;\n//   console.log(step_u)\n//   for (let u = 0.0; u < 1.0; u += step_u) {\n//     const r = parseInt(lerp(start.r, end.r, u));\n//     const g = parseInt(lerp(start.g, end.g, u));\n//     const b = parseInt(lerp(start.b, end.b, u));\n//     element.style.setProperty(property, `rgb(${r},${g},${b})`);\n//     await wait(interval);\n//   }\n// };\n// const menuColors = {\n//     blue: { r:22, g:94, b:161, shadow:{r:12, g:65, b:116} },\n//     red: { r:170, g:8, b:8, shadow:{r:80, g:0, b:0} },\n//     orange: {r:194, g:108, b:11, shadow:{r:97, g:63, b:0} },\n//     yellow: {r:202, g:165, b:0, shadow:{r:73, g:66, b:0} }\n// };\n","import React, { useEffect } from 'react';\nimport './App.css';\nimport SortingTimeVisualizer from './components/SortingTimeVisualizer';\nimport ReactGA from 'react-ga'; // https://github.com/react-ga/react-ga\n\n\nfunction App() {\n  // Google Analytics\n  useEffect(() => {\n    ReactGA.initialize('UA-174975160-2');\n    ReactGA.pageview(window.location.pathname);\n  }, []);\n\n  return (\n    <div className='App'>\n      <SortingTimeVisualizer/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/card-flip.2317ec81.mp3\";","module.exports = __webpack_public_path__ + \"static/media/card-flip-2.4f42bc57.mp3\";"],"sourceRoot":""}